;; from https://github.com/egraphs-good/egglog/issues/460#issuecomment-2465534261
;; to test visualization of large graphs

;; egglog eggcc-ackerman.egg --to-json --serialize-split-primitive-outputs --serialize-n-inline-leaves 10  --serialize-split-ops IntB,BoolB,IntT,BoolT,FloatT,StateT,PointerT,Int,Bool,Float,Const,TNil,TCons,TuplePointsTo,PtrPointsTo,Base,TupleT

; Prologue
; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  (FloatT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))


(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)

(function TNil () TypeList)
(function TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple


; =================================
; Assumptions
; =================================

(datatype Assumption
  ; Assume nothing
  (InFunc String)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Branch of the switch, and what the predicate is, and what the input is
  (InSwitch i64 Expr Expr)
  ; If the predicate was true, and what the predicate is, and what the input is
  (InIf bool Expr Expr)
)



; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg tuple_type) 1)` gets the second value in the argument with some tuple_type.
(function Arg (Type Assumption) Expr)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool)
  (Float f64))
; All leaf nodes need the type of the argument
; Type is the type of the bound argument in scope
(function Const (Constant Type Assumption) Expr)

; An empty tuple.
; Type is the type of the bound argument in scope
(function Empty (Type Assumption) Expr)


; =================================
; Operators
; =================================

(datatype TernaryOp
  ; given a pointer, value, and a state edge
  ; writes the value to the pointer and returns
  ; the resulting state edge
  (Write)
  (Select))
(datatype BinaryOp
  ;; integer operators
  (Add)
  (Sub)
  (Div)
  (Mul)
  (LessThan)
  (GreaterThan)
  (LessEq)
  (GreaterEq)
  (Eq)
  (Smin)
  (Smax)
  (Shl)
  (Shr)
  ;; float operators
  (FAdd)
  (FSub)
  (FDiv)
  (FMul)
  (FLessThan)
  (FGreaterThan)
  (FLessEq)
  (FGreaterEq)
  (FEq)
  (Fmin)
  (Fmax)
  ;; logical operators
  (And)
  (Or)
  ; given a pointer and a state edge
  ; loads the value at the pointer and returns (value, state edge)
  (Load)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd)
  ; given and value and a state edge, prints the value as a side-effect
  ; the value must be a base value, not a tuple
  ; returns an empty tuple
  (Print)
  ; given a pointer and state edge, frees the whole memory region at the pointer
  (Free))
(datatype UnaryOp
  (Not))

; Operators
(function Top   (TernaryOp Expr Expr Expr) Expr)
(function Bop   (BinaryOp Expr Expr) Expr)
(function Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(function Get   (Expr i64) Expr)
; (Alloc id amount state_edge pointer_type)
; allocate an integer amount of memory for a particular type
; returns (pointer to the allocated memory, state edge)
(function Alloc (i64 Expr Expr BaseType)      Expr)
;               name of func   arg
(function Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Single` and `Concat` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Single` for a tuple with one element.
; 3. Use `Concat` to append the elements from two tuples together.
; Nested tuples are not allowed.


; A tuple with a single element.
; Necessary because we only use `Concat` to add to tuples.
(function Single (Expr) Expr)
; Concat appends the elemnts from two tuples together
; e.g. (Concat (Concat (Single a) (Single b))
;              (Concat (Single c) (Single d))) = (a, b, c, d)
;                 expr1       expr2
(function Concat (Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; pred must be an integer
;                 pred  inputs   branches     chosen
(function Switch (Expr  Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred inputs   then else
(function If (Expr Expr     Expr Expr) Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; input must be a tuple
; pred must be a boolean
; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
; input must be the same type as (out1, out2, ..., outi)
;                  input   pred-and-body
(function DoWhile (Expr    Expr)                   Expr)


; =================================
; Top-level expressions
; =================================
(sort ProgramType)
; An entry function and a list of additional functions.
;                      entry function     other functions
(function Program     (Expr               ListExpr) ProgramType)
;                   name   input ty  output ty  output
(function Function (String Type      Type       Expr)      Expr)



; Rulesets
(ruleset always-run)
(ruleset error-checking)
(ruleset memory)
(ruleset memory-helpers)
(ruleset smem)

;; Initliazation
(relation bop->string (BinaryOp String))
(relation uop->string (UnaryOp String))
(relation top->string (TernaryOp String))
(bop->string (Add) "Add")
(bop->string (Sub) "Sub")
(bop->string (Div) "Div")
(bop->string (Mul) "Mul")
(bop->string (LessThan) "LessThan")
(bop->string (GreaterThan) "GreaterThan")
(bop->string (LessEq) "LessEq")
(bop->string (GreaterEq) "GreaterEq")
(bop->string (Eq) "Eq")
(bop->string (FAdd) "FAdd")
(bop->string (FSub) "FSub")
(bop->string (FDiv) "FDiv")
(bop->string (FMul) "FMul")
(bop->string (FLessThan) "FLessThan")
(bop->string (FGreaterThan) "FGreaterThan")
(bop->string (FLessEq) "FLessEq")
(bop->string (FGreaterEq) "FGreaterEq")
(bop->string (FEq) "FEq")
(bop->string (And) "And")
(bop->string (Or) "Or")
(bop->string (Load) "Load")
(bop->string (PtrAdd) "PtrAdd")
(bop->string (Print) "Print")
(bop->string (Free) "Free")
(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(function TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(function TypeList-length (TypeList) i64 :unextractable)
(function TypeList-ith (TypeList i64) BaseType :unextractable)
(function TypeList-suffix (TypeList i64) TypeList :unextractable)

(rule ((TupleT tylist)) ((union (TypeList-suffix tylist 0) tylist)) :ruleset type-helpers)

(rule ((= (TypeList-suffix top n) (TCons hd tl)))
    ((union (TypeList-ith top n) hd)
     (union (TypeList-suffix top (+ n 1)) tl)) :ruleset type-helpers)

(rule ((= (TypeList-suffix list n) (TNil)))
    ((set (TypeList-length list) n)) :ruleset type-helpers)

(rule ((TypeList-ith list i)
       (= (TypeList-length list) n)
       (>= i n))
      ((panic "TypeList-ith out of bounds")) :ruleset type-helpers)

(relation HasType (Expr Type))


;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; not okay unless we saturate type helpers.
      )
      ((extract "Expecting expression")
       (extract e)
       (extract "to have type")
       (extract expected)
       (extract "but got type")
       (extract actual)
       (extract "with message")
       (extract msg)
       (panic "type mismatch, use RUST_LOG=info to see type error"))
      :ruleset error-checking)

(relation HasArgType (Expr Type))

(rule ((HasArgType (Arg t1 ctx) t2)
       (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset error-checking)

(rule ((= lhs (Function name in out body))
       (HasArgType body ty)
       (HasArgType body ty2)
       (!= ty ty2))
      ((panic "arg type mismatch in function"))
      :ruleset error-checking)

; Propagate arg types up
(rule ((= lhs (Uop _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Top _ a b c))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Get e _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Alloc _id e state _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Call _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Single e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e1 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e2 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType pred ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred inputs (Cons branch rest)))
       (HasArgType branch ty)
       (HasType inputs ty2)
       (!= ty ty2))
      ((panic "switch branches then branch has incorrect input type"))
      :ruleset error-checking)
;; demand with one fewer branches
(rule ((= lhs (Switch pred inputs (Cons branch rest))))
      ((Switch pred inputs rest))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType t ty2)
       (!= ty ty2))
      ((panic "if branches then branch has incorrect input type"))
      :ruleset error-checking)
(rule ((= lhs (If c i t e))
       (HasType i ty)
       (HasArgType e ty2)
       (!= ty ty2))
      ((panic "if branches else branch has incorrect input type"))
      :ruleset error-checking)


(rule ((= lhs (DoWhile ins body))
       (HasArgType ins ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i) ty ctx)))
      ((HasType lhs (Base (IntT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b) ty ctx)))
      ((HasType lhs (Base (BoolT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Float b) ty ctx)))
      ((HasType lhs (Base (FloatT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Empty ty ctx)))
      ((HasType lhs (TupleT (TNil)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not)"))
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (Print) e state))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Print) e state))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset error-checking)

(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (PointerT _ty))))
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (IntT))))
      ((panic "Free expected pointer, received integer"))
      :ruleset error-checking)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (TupleT _ty)))
      ((panic "Free expected pointer, received tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (Bop (Load) e state))
        (HasType e (Base (PointerT ty)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (Base (IntT)))
      )
      ((panic "(Load) expected pointer, received int"))
      :ruleset error-checking)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset error-checking)

; Binary ops

;; Operators that have type Type -> Type -> Type
;; Note we only do this generic matching for binary
;; operator since there's a lot of them.
;; In the future we can also extend to other constructs.
(relation bop-of-type (BinaryOp Type))
(bop-of-type (Add) (Base (IntT)))
(bop-of-type (Sub) (Base (IntT)))
(bop-of-type (Div) (Base (IntT)))
(bop-of-type (Mul) (Base (IntT)))
(bop-of-type (FAdd) (Base (FloatT)))
(bop-of-type (FSub) (Base (FloatT)))
(bop-of-type (FDiv) (Base (FloatT)))
(bop-of-type (FMul) (Base (FloatT)))

(rule (
        (= lhs (Bop op e1 e2))
        (bop-of-type op ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop op e1 e2))
       (bop-of-type op ty)
       (bop->string op op-str))
      (
        (ExpectType e1 ty op-str)
        (ExpectType e2 ty op-str)
      )
      :ruleset type-analysis)

;; Operators that have type Float -> Float -> Bool
(relation bpred-of-type (BinaryOp Type))
(bpred-of-type (FLessThan) (Base (FloatT)))
(bpred-of-type (FLessEq) (Base (FloatT)))
(bpred-of-type (FGreaterThan) (Base (FloatT)))
(bpred-of-type (FGreaterEq) (Base (FloatT)))
(bpred-of-type (FEq) (Base (FloatT)))
(bpred-of-type (LessThan) (Base (IntT)))
(bpred-of-type (LessEq) (Base (IntT)))
(bpred-of-type (GreaterThan) (Base (IntT)))
(bpred-of-type (GreaterEq) (Base (IntT)))
(bpred-of-type (Eq) (Base (IntT)))
(bpred-of-type (And) (Base (BoolT)))
(bpred-of-type (Or) (Base (BoolT)))

(rule (
        (= lhs (Bop pred e1 e2))
        (bpred-of-type pred ty)
        (HasType e1 ty)
        (HasType e2 ty)
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop pred e1 e2))
       (bpred-of-type pred ty)
       (bop->string pred pred-str))
      (
        (ExpectType e1 ty pred-str)
        (ExpectType e2 ty pred-str)
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Write) ptr val state))
        (HasType ptr (Base (PointerT ty)))
        (HasType val (Base ty)) ; TODO need to support pointers to pointers
      )
      ((HasType lhs (Base (StateT)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
       (= lhs (Top (Write) ptr val state))
       (HasType ptr (Base (PointerT ty))))
      ((ExpectType val (Base ty) "(Write)"))
      :ruleset type-analysis)



(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (Base (PointerT ty)))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (Base (PointerT ty))))
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc _id amt state ty)))
      ((ExpectType amt (Base (IntT)) "(Alloc)"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc _id amt state ty))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e i))
        (HasType e (TupleT tylist))
      )
      ; TypeList-ith needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (Base (TypeList-ith tylist i))))
      :ruleset type-analysis)

(rule (
       (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
       (>= i len))
      ((panic "index out of bounds"))
      :ruleset error-checking)
(rule (
      (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
        (< i 0)
      )
      ((panic "negative index"))
      :ruleset error-checking)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset error-checking)

(rule (
        (= lhs (Single e))
        (HasType e (Base basety))
      )
      ((HasType lhs (TupleT (TCons basety (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ; TLConcat needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred inputs then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred inputs then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset error-checking)



(rule ((= lhs (Switch pred inputs branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred inputs (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred inputs (Cons branch rest)))
      ((Switch pred inputs rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred inputs rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred inputs (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred inputs rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset error-checking)

(rule ((Arg ty ctx))
      (
        (HasType (Arg ty ctx) ty)
        (HasArgType (Arg ty ctx) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base (PointerT ty)))
      )
      ((panic "loop input must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base (PointerT ty)))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset error-checking)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (BoolT) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (BoolT) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset error-checking)

; =================================
; Predicate to check if a type is not a state type
; =================================

(relation NonStateBaseType (BaseType))
(rule ()
     ((NonStateBaseType (IntT))
      (NonStateBaseType (BoolT))
      (NonStateBaseType (FloatT)))
  :ruleset type-analysis)
(rule ((= ptr-type (PointerT ty))
       (NonStateBaseType ty))
      ((NonStateBaseType ptr-type))
  :ruleset type-analysis)

(relation NonStateTypeList (TypeList))
(rule ()
     ((NonStateTypeList (TNil)))
  :ruleset type-analysis)
(rule ((NonStateTypeList tl)
       (NonStateBaseType hd)
       (= type-list (TCons hd tl)))
      ((NonStateTypeList type-list))
  :ruleset type-analysis)

(relation NonStateType (Type))
(rule ((NonStateBaseType bt)
       (= t (Base bt)))
      ((NonStateType t))
  :ruleset type-analysis)
(rule ((NonStateTypeList tl)
       (= t (TupleT tl)))
      ((NonStateType t))
  :ruleset type-analysis)

; =================================
; Functions
; =================================

(rule ((= lhs (Function name in-ty out-ty body)))
      (
        ; Arg should have the specified type in the body
        (HasArgType body in-ty)
        ; Expect the body to have the specified output type
        (ExpectType body out-ty "Function body had wrong type")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (Function name in-ty out-ty body)
      )
      ; Expect the arg to have the right type for the function
      ((ExpectType arg in-ty "function called with wrong arg type"))
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (Function name in-ty out-ty body)
        (HasType arg in-ty)
        ; We don't need to check the type of the function body, it will
        ; be checked elsewhere. If we did require (HasType body out-ty),
        ; recursive functions would not get assigned a type.
      )
      ((HasType lhs out-ty))
      :ruleset type-analysis)

; find which types are pure
(relation PureBaseType (BaseType))
(relation PureType (Type))
(relation PureTypeList (TypeList))

(PureBaseType (IntT))
(PureBaseType (BoolT))
(rule ((Base ty)
       (PureBaseType ty))
      ((PureType (Base ty)))
      :ruleset type-analysis)
(rule ((TupleT tylist)
       (PureTypeList tylist))
      ((PureType (TupleT tylist)))
      :ruleset type-analysis)
(rule ((TNil))
      ((PureTypeList (TNil)))
      :ruleset type-analysis)
(rule ((TCons hd tl)
       (PureBaseType hd)
       (PureTypeList tl))
      ((PureTypeList (TCons hd tl)))
      :ruleset type-analysis)

(function ListExpr-length (ListExpr) i64)
(function ListExpr-ith (ListExpr i64) Expr :unextractable)
(function ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(function Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred inputs branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-length (Expr) i64 :unextractable)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)

;; Create a Get for every index, and rewrite it to see through Concat
(rule ((Single expr)) ((union (Get (Single expr) 0) expr)) :ruleset always-run)
;; initial get
(rule ((> (tuple-length tuple) 0))
      ((Get tuple 0))
      :ruleset always-run)
;; next get
(rule ((= len (tuple-length tuple))
       (= ith (Get tuple i))
       (< (+ i 1) len)
       )
       ((Get tuple (+ 1 i)))
       :ruleset always-run)

;; descend left
(rule ((Get (Concat expr1 expr2) i)
       (= (tuple-length expr1) len1)
       (< i len1))
      ((union (Get (Concat expr1 expr2) i)
              (Get expr1 i)))
       :ruleset always-run)
;; descend right
(rule ((Get (Concat expr1 expr2) i)
       (= (tuple-length expr1) len1)
       (>= i len1))
      ((union (Get (Concat expr1 expr2) i)
              (Get expr2 (- i len1))))
       :ruleset always-run)


;; A temporary context.
;; Be sure to delete at the end of all actions or else!!!
;; This is safer than using a persistant context, since we may miss an important part of the query.
(function TmpCtx () Assumption)

(rule ((TmpCtx))
  ((panic "TmpCtx should not exist outside rule body"))
  :ruleset always-run)


(ruleset subsume-after-helpers)
;; After running the `saturating` ruleset, these if statements can be subsumed
(relation ToSubsumeIf (Expr Expr Expr Expr))
(rule ((ToSubsumeIf a b c d))
      ((subsume (If a b c d)))
      :ruleset subsume-after-helpers)



(relation ExprIsValid (Expr))
(relation ListExprIsValid (ListExpr))
(rule ((ExprIsValid (Function _name _tyin _tyout _out))) ((ExprIsValid _out)) :ruleset always-run)
(rule ((ExprIsValid (Top _op _x _y _z))) ((ExprIsValid _x)
(ExprIsValid _y)
(ExprIsValid _z)) :ruleset always-run)
(rule ((ExprIsValid (Bop _op _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Uop _op _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Get _tup _i))) ((ExprIsValid _tup)) :ruleset always-run)
(rule ((ExprIsValid (Concat _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Single _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Switch _pred _inputs _branches))) ((ExprIsValid _pred)
(ExprIsValid _inputs)
(ListExprIsValid _branches)) :ruleset always-run)
(rule ((ExprIsValid (If _pred _input _then _else))) ((ExprIsValid _pred)
(ExprIsValid _input)
(ExprIsValid _then)
(ExprIsValid _else)) :ruleset always-run)
(rule ((ExprIsValid (DoWhile _in _pred-and-output))) ((ExprIsValid _in)
(ExprIsValid _pred-and-output)) :ruleset always-run)
(rule ((ExprIsValid (Call _func _arg))) ((ExprIsValid _arg)) :ruleset always-run)
(rule ((ListExprIsValid (Cons _hd _tl))) ((ExprIsValid _hd)
(ListExprIsValid _tl)) :ruleset always-run)
(rule ((ExprIsValid (Alloc _id _e _state _ty))) ((ExprIsValid _e)
(ExprIsValid _state)) :ruleset always-run)
(relation ExprIsResolved (Expr))
(relation ListExprIsResolved (ListExpr))
(rule ((= lhs (Function _name _tyin _tyout _out)) (ExprIsResolved _out)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Const _n _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Top _op _x _y _z)) (ExprIsResolved _x)
(ExprIsResolved _y)
(ExprIsResolved _z)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Bop _op _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Uop _op _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Get _tup _i)) (ExprIsResolved _tup)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Concat _x _y)) (ExprIsResolved _x)
(ExprIsResolved _y)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Single _x)) (ExprIsResolved _x)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Switch _pred _inputs _branches)) (ExprIsResolved _pred)
(ExprIsResolved _inputs)
(ListExprIsResolved _branches)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (If _pred _input _then _else)) (ExprIsResolved _pred)
(ExprIsResolved _input)
(ExprIsResolved _then)
(ExprIsResolved _else)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (DoWhile _in _pred-and-output)) (ExprIsResolved _in)
(ExprIsResolved _pred-and-output)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Arg _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Call _func _arg)) (ExprIsResolved _arg)) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Empty _ty _ctx)) ) ((ExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Cons _hd _tl)) (ExprIsResolved _hd)
(ListExprIsResolved _tl)) ((ListExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Nil)) ) ((ListExprIsResolved lhs)) :ruleset always-run)
(rule ((= lhs (Alloc _id _e _state _ty)) (ExprIsResolved _e)
(ExprIsResolved _state)) ((ExprIsResolved lhs)) :ruleset always-run)
(relation BodyContainsExpr (Expr Expr))
(relation BodyContainsListExpr (Expr ListExpr))
(rule ((Function _name _tyin _tyout _out)) ((BodyContainsExpr (Function _name _tyin _tyout _out) _out)) :ruleset always-run)
(rule ((If _pred _input _then _else)) ((BodyContainsExpr (If _pred _input _then _else) _then) (BodyContainsExpr (If _pred _input _then _else) _else)) :ruleset always-run)
(rule ((DoWhile _in _pred-and-output)) ((BodyContainsExpr (DoWhile _in _pred-and-output) _pred-and-output)) :ruleset always-run)
(rule ((BodyContainsExpr body (Top _op _x _y _z))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y) (BodyContainsExpr body _z)) :ruleset always-run)
(rule ((BodyContainsExpr body (Bop _op _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Uop _op _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Get _tup _i))) ((BodyContainsExpr body _tup)) :ruleset always-run)
(rule ((BodyContainsExpr body (Concat _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Single _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Switch _pred _inputs _branches))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _inputs)) :ruleset always-run)
(rule ((BodyContainsExpr body (If _pred _input _then _else))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _input)) :ruleset always-run)
(rule ((BodyContainsExpr body (DoWhile _in _pred-and-output))) ((BodyContainsExpr body _in)) :ruleset always-run)
(rule ((BodyContainsExpr body (Call _func _arg))) ((BodyContainsExpr body _arg)) :ruleset always-run)
(rule ((BodyContainsListExpr body (Cons _hd _tl))) ((BodyContainsExpr body _hd)) :ruleset always-run)
(rule ((BodyContainsExpr body (Alloc _id _e _state _ty))) ((BodyContainsExpr body _e) (BodyContainsExpr body _state)) :ruleset always-run)

        (relation ExprIsPure (Expr))
        (relation ListExprIsPure (ListExpr))
        (relation BinaryOpIsPure (BinaryOp))
        (relation UnaryOpIsPure (UnaryOp))
        (relation TopIsPure (TernaryOp))
(TopIsPure (Select))
(BinaryOpIsPure (Add))
(BinaryOpIsPure (Sub))
(BinaryOpIsPure (Mul))
(BinaryOpIsPure (Div))
(BinaryOpIsPure (Eq))
(BinaryOpIsPure (LessThan))
(BinaryOpIsPure (GreaterThan))
(BinaryOpIsPure (LessEq))
(BinaryOpIsPure (GreaterEq))
(BinaryOpIsPure (Smax))
(BinaryOpIsPure (Smin))
(BinaryOpIsPure (Shl))
(BinaryOpIsPure (Shr))
(BinaryOpIsPure (FAdd))
(BinaryOpIsPure (FSub))
(BinaryOpIsPure (FMul))
(BinaryOpIsPure (FDiv))
(BinaryOpIsPure (FEq))
(BinaryOpIsPure (FLessThan))
(BinaryOpIsPure (FGreaterThan))
(BinaryOpIsPure (FLessEq))
(BinaryOpIsPure (FGreaterEq))
(BinaryOpIsPure (Fmax))
(BinaryOpIsPure (Fmin))
(BinaryOpIsPure (And))
(BinaryOpIsPure (Or))
(BinaryOpIsPure (PtrAdd))
(UnaryOpIsPure (Not))

                (rule ((Function _name _tyin _tyout _out) (ExprIsPure _out))
                      ((ExprIsPure (Function _name _tyin _tyout _out)))
                      :ruleset always-run)

                (rule ((Const _n _ty _ctx))
                      ((ExprIsPure (Const _n _ty _ctx)))
                      :ruleset always-run)

                (rule ((Top _op _x _y _z) (ExprIsPure _x) (ExprIsPure _y) (ExprIsPure _z))
                      ((ExprIsPure (Top _op _x _y _z)))
                      :ruleset always-run)

                (rule ((Bop _op _x _y) (BinaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y))
                      ((ExprIsPure (Bop _op _x _y)))
                      :ruleset always-run)

                (rule ((Uop _op _x) (UnaryOpIsPure _op) (ExprIsPure _x))
                      ((ExprIsPure (Uop _op _x)))
                      :ruleset always-run)

                (rule ((Get _tup _i) (ExprIsPure _tup))
                      ((ExprIsPure (Get _tup _i)))
                      :ruleset always-run)

                (rule ((Concat _x _y) (ExprIsPure _x) (ExprIsPure _y))
                      ((ExprIsPure (Concat _x _y)))
                      :ruleset always-run)

                (rule ((Single _x) (ExprIsPure _x))
                      ((ExprIsPure (Single _x)))
                      :ruleset always-run)

                (rule ((Switch _pred _inputs _branches) (ExprIsPure _pred) (ExprIsPure _inputs) (ListExprIsPure _branches))
                      ((ExprIsPure (Switch _pred _inputs _branches)))
                      :ruleset always-run)

                (rule ((If _pred _input _then _else) (ExprIsPure _pred) (ExprIsPure _input) (ExprIsPure _then) (ExprIsPure _else))
                      ((ExprIsPure (If _pred _input _then _else)))
                      :ruleset always-run)

                (rule ((DoWhile _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
                      ((ExprIsPure (DoWhile _in _pred-and-output)))
                      :ruleset always-run)

                (rule ((Arg _ty _ctx))
                      ((ExprIsPure (Arg _ty _ctx)))
                      :ruleset always-run)

            (rule ((Call _f _arg) (ExprIsPure _arg) (ExprIsPure (Function _f inty outty out)))
                  ((ExprIsPure (Call _f _arg)))
                  :ruleset always-run)

                (rule ((Empty _ty _ctx))
                      ((ExprIsPure (Empty _ty _ctx)))
                      :ruleset always-run)

                (rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
                      ((ListExprIsPure (Cons _hd _tl)))
                      :ruleset always-run)

                (rule ((Nil))
                      ((ListExprIsPure (Nil)))
                      :ruleset always-run)

; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)

(function AddContext (Assumption Expr) Expr :unextractable)
(function AddContextList (Assumption ListExpr) ListExpr :unextractable)

;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (AddContext ctx inner))
   (= inner (AddContext ctx expr)))
  ((union lhs inner))
  :ruleset context)


;; ############################## Base cases- leaf nodes

;; replace existing contexts that are around leaf nodes
;; AddContext assumes the new context is more specific than the old one
(rule ((= lhs (AddContext ctx (Arg ty oldctx))))
      ((union lhs (Arg ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Const c ty oldctx))))
      ((union lhs (Const c ty ctx)))
      :ruleset context)
(rule ((= lhs (AddContext ctx (Empty ty oldctx))))
      ((union lhs (Empty ty ctx)))
      :ruleset context)




;; ######################################### Operators
(rewrite (AddContext ctx (Top op c1 c2 c3))
         (Top op
           (AddContext ctx c1)
           (AddContext ctx c2)
           (AddContext ctx c3))
               :ruleset context)
(rewrite (AddContext ctx (Bop op c1 c2))
         (Bop op
           (AddContext ctx c1)
           (AddContext ctx c2))
               :ruleset context)
(rewrite (AddContext ctx (Uop op c1))
         (Uop op (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Get c1 index))
         (Get (AddContext ctx c1) index)
               :ruleset context)
(rewrite (AddContext ctx (Alloc id c1 state ty))
         (Alloc id (AddContext ctx c1) (AddContext ctx state) ty)
         :ruleset context)
(rewrite (AddContext ctx (Call name c1))
         (Call name (AddContext ctx c1))
         :ruleset context)

(rewrite (AddContext ctx (Single c1))
         (Single (AddContext ctx c1))
         :ruleset context)
(rewrite (AddContext ctx (Concat c1 c2))
         (Concat
           (AddContext ctx c1)
           (AddContext ctx c2))
         :ruleset context)

;; ################################### List operators

(rewrite (AddContextList ctx (Nil))
         (Nil)
         :ruleset context)

(rewrite (AddContextList ctx (Cons c1 rest))
         (Cons (AddContext ctx c1)
               (AddContextList ctx rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (AddContext ctx (Switch pred inputs branches))
         (Switch (AddContext ctx pred)
                 (AddContext ctx inputs)
                 branches)
         :ruleset context)

;; For stop at region, still add context to inputs
(rule ((= lhs (AddContext ctx (If pred inputs c1 c2))))
      ((union lhs
         (If (AddContext ctx pred)
             (AddContext ctx inputs)
             c1
             c2)))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (AddContext ctx (DoWhile inputs outputs))))
      ((union lhs
        (DoWhile
          (AddContext ctx inputs)
          outputs)))
       :ruleset context)


;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)
(ruleset apply-subst-unions)
(ruleset cleanup-subst)

;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces the leaf context in `to` with `assumption` using `AddContext`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(function Subst (Assumption Expr Expr) Expr :unextractable)

;; Used to delay unions for the subst ruleset.
;; This is necessary because substitution may not terminate if it can
;; observe its own results- it may create infinitly large terms.
;; Instead, we phase substitution by delaying resulting unions in this table.
;; After applying this table, substitutions and this table are cleared.
(function DelayedSubstUnion (Expr Expr) Expr :unextractable)

;; add a type rule to get the arg type of a substitution
;; this enables nested substitutions
(rule ((= lhs (Subst assum to in))
       (HasArgType to ty))
      ((HasArgType lhs ty))
      :ruleset subst)

;; leaf node with context
;; replace this context- subst assumes the context is more specific
(rule ((= lhs (Subst assum to (Arg ty oldctx)))
       )
      ;; add the assumption `to`
      ((DelayedSubstUnion lhs (AddContext assum to)))
      :ruleset subst)
(rule ((= lhs (Subst assum to (Const c ty oldctx)))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Const c newty assum)))
      :ruleset subst)
(rule ((= lhs (Subst assum to (Empty ty oldctx)))
       (HasArgType to newty))
      ((DelayedSubstUnion lhs (Empty newty assum)))
      :ruleset subst)

;; Operators
(rule ((= lhs (Subst assum to (Top op c1 c2 c3)))
       (ExprIsResolved (Top op c1 c2 c3)))
      ((DelayedSubstUnion lhs
         (Top op (Subst assum to c1)
                 (Subst assum to c2)
                 (Subst assum to c3))))
         :ruleset subst)

(rule ((= lhs (Subst assum to (Bop op c1 c2)))
       (ExprIsResolved (Bop op c1 c2)))
      ((DelayedSubstUnion lhs
         (Bop op (Subst assum to c1)
                 (Subst assum to c2))))
         :ruleset subst)
(rule ((= lhs (Subst assum to (Uop op c1)))
       (ExprIsResolved (Uop op c1)))
      ((DelayedSubstUnion lhs
         (Uop op (Subst assum to c1))))
         :ruleset subst)

(rule ((= lhs (Subst assum to (Get c1 index)))
       (ExprIsResolved (Get c1 index)))
      ((DelayedSubstUnion lhs
         (Get (Subst assum to c1) index)))
         :ruleset subst)
(rule ((= lhs (Subst assum to (Alloc id c1 c2 ty)))
       (ExprIsResolved (Alloc id c1 c2 ty)))
      ((DelayedSubstUnion lhs
         (Alloc id (Subst assum to c1)
                   (Subst assum to c2)
                   ty)))
         :ruleset subst)
(rule ((= lhs (Subst assum to (Call name c1)))
       (ExprIsResolved (Call name c1)))
      ((DelayedSubstUnion lhs
         (Call name (Subst assum to c1))))
         :ruleset subst)


;; Tuple operators
(rule ((= lhs (Subst assum to (Single c1)))
       (ExprIsResolved (Single c1)))
      ((DelayedSubstUnion lhs
         (Single (Subst assum to c1))))
         :ruleset subst)
(rule ((= lhs (Subst assum to (Concat c1 c2)))
       (ExprIsResolved (Concat c1 c2)))
      ((DelayedSubstUnion lhs
         (Concat (Subst assum to c1)
                 (Subst assum to c2))))
         :ruleset subst)

;; Control flow
(rule ((= lhs (Subst assum to inner))
       (= inner (Switch pred inputs c1))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (Switch (Subst assum to pred)
                 (Subst assum to inputs)
                 c1)))
         :ruleset subst)
(rule ((= lhs (Subst assum to inner))
       (= inner (If pred inputs c1 c2))
       (ExprIsResolved inner))
      ((DelayedSubstUnion lhs
         (If (Subst assum to pred)
             (Subst assum to inputs)
             c1
             c2)))
         :ruleset subst)
(rule ((= lhs (Subst assum to (DoWhile in out)))
       (ExprIsResolved (DoWhile in out)))
      ((DelayedSubstUnion lhs
         (DoWhile (Subst assum to in)
                  out)))
      :ruleset subst)

;; substitute into function (convenience for testing)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :when ((ExprIsResolved body))
         :ruleset subst)



;; ########################### Apply subst unions

(rule ((DelayedSubstUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-subst-unions)


;; ########################### Cleanup subst and DelayedSubstUnion

(rule ((DelayedSubstUnion lhs rhs))
      ((subsume (DelayedSubstUnion lhs rhs)))
      :ruleset cleanup-subst)

; this cleanup is important- if we don't subsume these substitutions, they
; may oberve their own results and create infinitely sized terms.
; ex: get(parallel!(arg(), int(2)), 0) ignores the first element of the tuple
; so it's equivalent to infinite other times with any other value as the first element of the tuple.
; Check ExprIsResolved to confirm that the substitution finished (all sub-substitutions are done).
(rule ((ExprIsResolved (Subst assum to in)))
      ((subsume (Subst assum to in)))
      :ruleset cleanup-subst)

; We only have context for Exprs, not ListExprs.
(relation ContextOf (Expr Assumption))

(rule ((Arg ty ctx))
      ((ContextOf (Arg ty ctx) ctx))
      :ruleset always-run)
(rule ((Const c ty ctx))
      ((ContextOf (Const c ty ctx) ctx))
      :ruleset always-run)
(rule ((Empty ty ctx))
      ((ContextOf (Empty ty ctx) ctx))
        :ruleset always-run)

; Error checking - each expr should only have a single context
(rule ((ContextOf x ctx1)
       (ContextOf x ctx2)
       (!= ctx1 ctx2))
     (
         (panic "Equivalent expressions have nonequivalent context, breaking the single context invariant.")
     )
     :ruleset error-checking)


(rule ((Top op x y z) (ContextOf x ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf y ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf z ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf x ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf y ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Uop op x) (ContextOf x ctx))
    ((ContextOf (Uop op x) ctx)) :ruleset always-run)

(rule ((Get tup i) (ContextOf tup ctx))
    ((ContextOf (Get tup i) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf x ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf y ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Single x) (ContextOf x ctx))
    ((ContextOf (Single x) ctx)) :ruleset always-run)

(rule ((Switch pred inputs branches) (ContextOf pred ctx))
    ((ContextOf (Switch pred inputs branches) ctx)) :ruleset always-run)

(rule ((If pred inputs then else) (ContextOf pred ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run)

(rule ((If pred inputs then else) (ContextOf inputs ctx))
    ((ContextOf (If pred inputs then else) ctx)) :ruleset always-run)

(rule ((DoWhile in pred-and-output) (ContextOf in ctx))
    ((ContextOf (DoWhile in pred-and-output) ctx)) :ruleset always-run)

(rule ((Call func arg) (ContextOf arg ctx))
    ((ContextOf (Call func arg) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf e ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf state ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(ruleset canon)

; Commutativity
(rewrite (Bop (Add) x y) (Bop (Add) y x) :ruleset canon)
(rewrite (Bop (Mul) x y) (Bop (Mul) y x) :ruleset canon)
(rewrite (Bop (Eq) x y) (Bop (Eq) y x) :ruleset canon)
(rewrite (Bop (And) x y) (Bop (And) y x) :ruleset canon)
(rewrite (Bop (Or) x y) (Bop (Or) y x) :ruleset canon)

; Canonicalize to <
; x > y ==> y < x
(rewrite (Bop (GreaterThan) x y) (Bop (LessThan) y x) :ruleset canon)

; x >= y ==> y < x + 1
; x >= y ==> y - 1 < x
(rule (
        (= lhs (Bop (GreaterEq) x y))
        (HasArgType x ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) y (Bop (Add) x (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) y (Const (Int 1) ty ctx)) x))
      )
      :ruleset canon)

; x <= y ==> x < y + 1
; x <= y ==> x - 1 < y
(rule (
        (= lhs (Bop (LessEq) x y))
        (HasArgType y ty)
        (ContextOf lhs ctx)
      )
      (
        (union lhs (Bop (LessThan) x (Bop (Add) y (Const (Int 1) ty ctx))))
        (union lhs (Bop (LessThan) (Bop (Sub) x (Const (Int 1) ty ctx)) y))
      )
      :ruleset canon)


; Make Concats right-deep
(rewrite (Concat (Concat a b) c)
         (Concat a (Concat b c))
         :ruleset always-run)
; Simplify Concat's with empty
(rewrite (Concat (Empty ty ctx) x)
         x
         :ruleset always-run)
(rewrite (Concat x (Empty ty ctx))
         x
         :ruleset always-run)

; Make a tuple that is a sub-range of another tuple
;                   tuple start len
(function SubTuple (Expr  i64   i64) Expr :unextractable)

(rewrite (SubTuple expr x 0)
         (Empty ty ctx)
         :when ((HasArgType expr ty) (ContextOf expr ctx))
         :ruleset always-run)

(rewrite (SubTuple expr x 1)
         (Single (Get expr x))
         :ruleset always-run)

(rewrite (SubTuple expr a b)
         (Concat (Single (Get expr a)) (SubTuple expr (+ a 1) (- b 1)))
         :when ((> b 1))
         :ruleset always-run)

; Helper functions to remove one element from a tuple or type list
;                           tuple    idx
(function TupleRemoveAt    (Expr     i64) Expr     :unextractable)
(rewrite (TupleRemoveAt tuple idx)
         (Concat (SubTuple tuple 0 idx)
                 (SubTuple tuple (+ idx 1) (- len (+ idx 1))))
         :when ((= len (tuple-length tuple)))
         :ruleset always-run)
(rule ((TupleRemoveAt tuple idx)
       (= len (tuple-length tuple))
       (>= idx len))
      ((panic "Index out of bounds for TupleRemoveAt")) :ruleset always-run)

(function TypeListRemoveAt (TypeList i64) TypeList :unextractable)
(rule ((TypeListRemoveAt (TNil) _idx))
      ((panic "Index out of bounds for TypeListRemoveAt.")) :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) 0)
         xs
         :ruleset type-helpers)
(rewrite (TypeListRemoveAt (TCons x xs) idx)
         (TCons x (TypeListRemoveAt xs (- idx 1)))
         :when ((> idx 0))
         :ruleset type-helpers)

;; Compute the tree size of program, not dag size
(function Expr-size (Expr) i64 :unextractable :merge (min old new) )
(function ListExpr-size (ListExpr) i64 :unextractable :merge (min old new))

(rule ((= expr (Function name tyin tyout out))
       (= sum (Expr-size out)))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Const n ty assum)))
      ((set (Expr-size expr) 1))  :ruleset always-run)

(rule ((= expr (Top op x y z))
       (= sum (+ (Expr-size z) (+ (Expr-size y) (Expr-size x)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Bop op x y))
       (= sum (+ (Expr-size y) (Expr-size x))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Uop op x))
       (= sum (Expr-size x)))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Get tup i))
       (= sum (Expr-size tup)))
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Concat x y))
       (= sum (+ (Expr-size y) (Expr-size x))))
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Single x))
       (= sum (Expr-size x)))
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Switch pred inputs branches))
       (= sum  (+ (Expr-size inputs) (+ (ListExpr-size branches) (Expr-size pred)))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (If pred inputs then else))
       (= sum (+ (Expr-size inputs) (+ (Expr-size else) (+ (Expr-size then) (Expr-size pred))))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (DoWhile in pred-and-output))
       (= sum (+ (Expr-size pred-and-output) (Expr-size in))))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Arg ty assum)))
      ((set (Expr-size expr) 1)) :ruleset always-run)

(rule ((= expr (Call func arg))
       (= sum (Expr-size arg)))
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((Empty ty assum)) ((set (Expr-size (Empty ty assum)) 0))  :ruleset always-run)

(rule ((= expr (Cons hd tl))
       (= sum (+ (ListExpr-size tl) (Expr-size hd))))
      ((set (ListExpr-size expr) sum)) :ruleset always-run)

(rule ((Nil))
      ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)

(rule ((= expr (Alloc id e state ty)) ;; do state edge's expr should be counted?
        (= sum (Expr-size e)))
        ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

;; Like Subst but for dropping inputs to a region
;; See subst.egg for more implementation documentation

(ruleset drop)
(ruleset apply-drop-unions)
(ruleset cleanup-drop)

;; (DropAt ctx idx in) removes all references to `(Get (Arg ...) idx)` in `in`.
;; It also replaces the leaf contexts with `ctx` and fixes up argument types,
;; as well as updating `(Get (Arg ...) j)` to `(Get (Arg ...) (- j 1))` for j > idx.
(function DropAt (Assumption i64 Expr) Expr :unextractable)
(function DelayedDropUnion (Expr Expr) Expr :unextractable)

;; Helper that precomputes the arg type that we need
(function DropAtInternal (Type Assumption i64 Expr) Expr :unextractable)
(rule ((= lhs (DropAt ctx idx in))
       (HasArgType in (TupleT oldty)))

      ((let newty (TupleT (TypeListRemoveAt oldty idx)))
       (union lhs (DropAtInternal newty ctx idx in)))
      :ruleset drop)

;; Leaves
(rule ((= lhs (DropAtInternal newty newctx idx (Const c oldty oldctx))))
      ((DelayedDropUnion lhs (Const c newty newctx)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Empty oldty oldctx))))
      ((DelayedDropUnion lhs (Empty newty newctx)))
      :ruleset drop)
; get stuck on purpose if `i = idx` or if we find a bare `Arg`
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (< i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) i)))
      :ruleset drop)
(rule ((= lhs (DropAtInternal newty newctx idx (Get (Arg oldty oldctx) i)))
       (> i idx))
      ((DelayedDropUnion lhs (Get (Arg newty newctx) (- i 1))))
      :ruleset drop)

;; Operators
(rule ((= lhs (DropAtInternal newty newctx idx (Top op c1 c2 c3)))
       (ExprIsResolved (Top op c1 c2 c3)))
      ((DelayedDropUnion lhs (Top op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            (DropAtInternal newty newctx idx c3))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Bop op c1 c2)))
       (ExprIsResolved (Bop op c1 c2)))
      ((DelayedDropUnion lhs (Bop op
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Uop op c1)))
       (ExprIsResolved (Uop op c1)))
      ((DelayedDropUnion lhs (Uop op
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; this is okay because we get stuck at `Arg`s
(rule ((= lhs (DropAtInternal newty newctx idx (Get c1 index)))
       (ExprIsResolved (Get c1 index)))
      ((DelayedDropUnion lhs (Get
            (DropAtInternal newty newctx idx c1)
            index)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Alloc id c1 c2 ty)))
       (ExprIsResolved (Alloc id c1 c2 ty)))
      ((DelayedDropUnion lhs (Alloc id
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2)
            ty)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Call name c1)))
       (ExprIsResolved (Call name c1)))
      ((DelayedDropUnion lhs (Call name
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

;; Tuple operators
(rule ((= lhs (DropAtInternal newty newctx idx (Single c1)))
       (ExprIsResolved (Single c1)))
      ((DelayedDropUnion lhs (Single
            (DropAtInternal newty newctx idx c1))))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (Concat c1 c2)))
       (ExprIsResolved (Concat c1 c2)))
      ((DelayedDropUnion lhs (Concat
            (DropAtInternal newty newctx idx c1)
            (DropAtInternal newty newctx idx c2))))
      :ruleset drop)

;; Control flow
(rule ((= lhs (DropAtInternal newty newctx idx (Switch pred inputs c1)))
       (ExprIsResolved (Switch pred inputs c1)))
      ((DelayedDropUnion lhs (Switch
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (If pred inputs c1 c2)))
       (ExprIsResolved (If pred inputs c1 c2)))
      ((DelayedDropUnion lhs (If
            (DropAtInternal newty newctx idx pred)
            (DropAtInternal newty newctx idx inputs)
            c1
            c2)))
      :ruleset drop)

(rule ((= lhs (DropAtInternal newty newctx idx (DoWhile in out)))
       (ExprIsResolved (DoWhile in out)))
      ((DelayedDropUnion lhs (DoWhile
            (DropAtInternal newty newctx idx in)
            out)))
      :ruleset drop)

(rewrite (DropAtInternal newty newctx idx (Function name inty outty body))
         (Function name inty outty (DropAtInternal newty newctx idx body))
         :when ((ExprIsResolved body))
         :ruleset drop)



;; ########################### Apply drop unions

(rule ((DelayedDropUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-drop-unions)

;; ########################### Cleanup Dropat, DropAtInternal and DelayedDropUnion

(rule ((ExprIsResolved (DropAt newctx idx in)))
      ((subsume (DropAt newctx idx in)))
      :ruleset cleanup-drop)

(rule ((ExprIsResolved (DropAtInternal newty newctx idx in)))
      ((subsume (DropAtInternal newty newctx idx in)))
      :ruleset cleanup-drop)

(rule ((DelayedDropUnion lhs rhs))
      ((subsume (DelayedDropUnion lhs rhs)))
      :ruleset cleanup-drop)

(ruleset interval-analysis)

(datatype Bound
  (IntB i64)
  (BoolB bool)
  (bound-max Bound Bound)
  (bound-min Bound Bound))

; bound tables
(function lo-bound (Expr) Bound :unextractable :merge (bound-max old new))
(function hi-bound (Expr) Bound :unextractable :merge (bound-min old new))

; if lo > hi, panic
; We can't run these rules because unreachable branches may have impossible intervals
; Consider re-enabling these rules if we implement an is-reachable analysis
; (rule (
;         (= (IntB lo) (lo-bound expr))
;         (= (IntB hi) (hi-bound expr))
;         (> lo hi)
;       )
;       ((panic "lo bound greater than hi bound"))
;       :ruleset interval-analysis)
; (rule (
;         (= (BoolB true) (lo-bound expr))
;         (= (BoolB false) (hi-bound expr))
;       )
;       ((panic "lo bound greater than hi bound"))
;       :ruleset interval-analysis)

; combinators
(rewrite (bound-max (IntB x) (IntB y))
         (IntB (max x y))
         :ruleset interval-analysis)
(rewrite (bound-min (IntB x) (IntB y))
         (IntB (min x y))
         :ruleset interval-analysis)
(rewrite (bound-max (BoolB x) (BoolB y))
         (BoolB (or x y))
         :ruleset interval-analysis)
(rewrite (bound-min (BoolB x) (BoolB y))
         (BoolB (and x y))
         :ruleset interval-analysis)

; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty ctx)))
      (
        (set (lo-bound lhs) (IntB x))
        (set (hi-bound lhs) (IntB x))
      )
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty ctx)))
      (
        (set (lo-bound lhs) (BoolB x))
        (set (hi-bound lhs) (BoolB x))
      )
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntB x) (lo-bound expr))
       (= (IntB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Int x) ty ctx)))
      :ruleset interval-analysis)

(rule (
       (= (BoolB x) (lo-bound expr))
       (= (BoolB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool x) ty ctx)))
      :ruleset interval-analysis)

; lower bound being true means the bool must be true
(rule (
       (= (BoolB true) (lo-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool true) ty ctx)))
      :ruleset interval-analysis)

; upper bound being false means the bool must be false
(rule (
       (= (BoolB false) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool false) ty ctx)))
      :ruleset interval-analysis)

; =================================
; Arithmetic
; =================================
; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (lo-bound lhs) (IntB (+ la lb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Add) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (IntB (+ ha hb))))
      :ruleset interval-analysis)

; - a b interval is (- la hb) (- ha lb)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (lo-bound lhs) (IntB (- la hb))))
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (Sub) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      ((set (hi-bound lhs) (IntB (- ha lb))))
      :ruleset interval-analysis)

; Multiplication for two constants
; TODO: Make fancier interval analysis
(rule (
       (= lhs (Bop (Mul) a b))
       (= (IntB x) (lo-bound a))
       (= (IntB x) (hi-bound a))
       (= (IntB y) (lo-bound b))
       (= (IntB y) (hi-bound b))
      )
      (
       (set (lo-bound lhs) (IntB (* x y)))
       (set (hi-bound lhs) (IntB (* x y)))
      )
      :ruleset interval-analysis)

; negative * negative is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB hi-y) (hi-bound y))
        (<= hi-x 0)
        (<= hi-y 0)
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; negative * positive is negative
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB hi-x) (hi-bound x))
        (= (IntB lo-y) (lo-bound y))
        (<= hi-x 0) ; x <= 0 (x is negative)
        (>= lo-y 0) ; y >= 0 (y is positive)
      )
      ((set (hi-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; positive * positive is positive
(rule (
        (= lhs (Bop (Mul) x y))
        (= (IntB lo-x) (lo-bound x))
        (= (IntB lo-y) (lo-bound y))
        (>= lo-x 0)
        (>= lo-y 0)
      )
      ((set (lo-bound lhs) (IntB 0)))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB ha) (hi-bound a))
       (= (IntB lb) (lo-bound b))
      )
      (
       (set (lo-bound lhs) (BoolB (bool-< ha lb)))
      )
      :ruleset interval-analysis)
(rule (
       (= lhs (Bop (LessThan) a b))
       (= (IntB la) (lo-bound a))
       (= (IntB hb) (hi-bound b))
      )
      ((set (hi-bound lhs) (BoolB (bool-< la hb))))
      :ruleset interval-analysis)

; =================================
; Conditionals
; =================================
; if the predicate is true, merge with then branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB true) (lo-bound cond))
      )
      ((union lhs (Subst if_ctx inputs thn)))
      :ruleset interval-analysis)

; if the predicate is false, merge with else branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB false) (hi-bound cond))
      )
      ((union lhs (Subst if_ctx inputs els)))
      :ruleset interval-analysis)

; lo-bound of If is the min of the lower bounds
; hi-bound of If is the max of the upper bounds
(rule (
        (= lhs (If cond inputs thn els))
        (= lo-thn (lo-bound thn))
        (= lo-els (lo-bound els))
      )
      ((set (lo-bound lhs) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound thn))
       (= hi-els (hi-bound els))
      )
      ((set (hi-bound lhs) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; Same rules, but for Ifs that have multiple outputs
(rule (
        (= lhs (If pred inputs thn els))
        (= lo-thn (lo-bound (Get thn i)))
        (= lo-els (lo-bound (Get els i)))
      )
      ((set (lo-bound (Get lhs i)) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound (Get thn i)))
       (= hi-els (hi-bound (Get els i)))
      )
      ((set (hi-bound (Get lhs i)) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)

; If the If takes a tuple
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was true, so we know expr is at most (hi-bound value) - 1
      ((set (hi-bound (Get ctx i)) (IntB (- v 1))))
      :ruleset interval-analysis)
(rule (
        ; expr < value
        (= pred (Bop (LessThan) expr value))
        (= if_e (If pred inputs then else))
        ; the left operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the right operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; expr < value was false, so we know expr is at least (lo-bound value)
      ((set (lo-bound (Get ctx i)) (IntB v)))
      :ruleset interval-analysis)

(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has a lower bound
        (= (IntB v) (lo-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf true pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was true, so we know expr is at least (lo-bound value) + 1
      ((set (lo-bound (Get ctx i)) (IntB (+ v 1))))
      :ruleset interval-analysis)
(rule (
        ; value < expr
        (= pred (Bop (LessThan) value expr))
        (= if_e (If pred inputs then else))
        ; the right operand of the < is an input to the if region
        (= expr (Get inputs i))
        ; the left operand of the < has an upper bound
        (= (IntB v) (hi-bound value))
        ; context node inside the if region
        (= ctx (Arg ty (InIf false pred inputs)))
        (HasType inputs ty)
      )
      ; value < expr was false, so we know expr is at most (hi-bound value)
      ((set (hi-bound (Get ctx i)) (IntB v)))
      :ruleset interval-analysis)

;; Push intervals for inputs into if region
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= lo (lo-bound (Get inputs i)))

      )
      ((set (lo-bound (Get ctx i)) lo))
      :ruleset interval-analysis)
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= hi (hi-bound (Get inputs i)))

      )
      ((set (hi-bound (Get ctx i)) hi))
      :ruleset interval-analysis)

; (if (a == b) thn els)
; in the thn branch, we know that a has the same bounds as b
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx  (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB lo) (lo-bound val))
      )
      ((set (lo-bound (Get ctx i)) (IntB lo)))
      :ruleset interval-analysis)
(rule (
       (= pred (Bop (Eq) expr val))
       (= if_e (If pred inputs thn els))
       ; the left operand of the == is an input to the if region
       (= expr (Get inputs i))
       (= ctx (Arg ty (InIf true pred inputs)))
       (HasType inputs ty)
       (= (IntB hi) (hi-bound val))
      )
      ((set (hi-bound (Get ctx i)) (IntB hi)))
      :ruleset interval-analysis)


(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       ;; note that some_ctx is not the same as (InLoop inputs outputs)
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (lo-bound (Get inputs ith)))
      )
      (
       (set (lo-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)
(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       ;; in the loop, the argument is passed through
       (= (Get (Arg ty some_ctx) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (hi-bound (Get inputs ith)))
      )
      (
       (set (hi-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)


(ruleset switch_rewrite)
(ruleset always-switch-rewrite)

; if a < b then a else b ~~> (min a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))
      )
      ((union (Get if_e k) (Bop (Smin) a b)))
      :ruleset switch_rewrite)

; if a < b then b else a ~~> (max a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then b else a
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) j))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) i))
      )
      ((union (Get if_e k) (Bop (Smax) a b)))
      :ruleset switch_rewrite)

; if pred then a else b ~~> (select pred a b)
; where a and b are inputs to the region
(rule (
       (= if_e (If pred inputs thn els))
       (= a (Get inputs i))
       (= b (Get inputs j))

       ; if pred then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))

       ; If i = j, then the arg is just passed through the if, and we
       ; don't need a select. This will get handled by the passthrough rules.
       (!= i j)
       )
       (
       (union (Get if_e k) (Top (Select) pred a b))
       )
       :ruleset switch_rewrite)

(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)
       (= (Get thn i) (Const x _ty (InIf true pred inputs)))
       (= (Get els i) (Const y _ty (InIf false pred inputs)))
      )
      ((union (Get if_e i) (Top (Select) pred (Const x ty ctx) (Const y ty ctx))))
      :ruleset switch_rewrite)

; if pred then A else Const -> select pred A Const
; where A is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       ; input to the if
       (= a (Get inputs i))
       (= (Get thn k) (Get (Arg _ty (InIf true pred inputs)) i))

       (= els_out (Get els k))
       (= (IntB y) (lo-bound els_out))
       (= (IntB y) (hi-bound els_out))
       )
       (
       (union (Get if_e k) (Top (Select) pred a (Const (Int y) ty ctx)))
       )
       :ruleset switch_rewrite
)

; if pred then Const else B -> select pred Const B
; where B is an input to the region
(rule (
       (= if_e (If pred inputs thn els))
       (ContextOf if_e ctx)
       (HasArgType if_e ty)

       (= thn_out (Get thn k))
       (= (IntB y) (lo-bound thn_out))
       (= (IntB y) (hi-bound thn_out))

       ; input to the if
       (= b (Get inputs i))
       (= (Get els k) (Get (Arg _ty (InIf false pred inputs)) i))
      )
      (
       (union (Get if_e k) (Top (Select) pred (Const (Int y) ty ctx) b))
      )
      :ruleset switch_rewrite
)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf true  a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let inner_X (AddContext (InIf true  inner_pred sub_arg_true) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_true) Y))
       (let outer_Y (Subst      (InIf false a          outer_ins) sub_arg_false Y))

       (let inner (If inner_pred sub_arg_true inner_X inner_Y))
       (union lhs (If a          outer_ins    inner   outer_Y)))

       :ruleset switch_rewrite)

; if (a or b) X Y ~~> if a X (if b X Y)
(rule ((= lhs (If (Bop (Or) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (Arg outer_ins_ty (InIf false a outer_ins)) 0))
       (let sub_arg_true  (SubTuple (Arg outer_ins_ty (InIf true  a outer_ins)) 1 len))
       (let sub_arg_false (SubTuple (Arg outer_ins_ty (InIf false a outer_ins)) 1 len))

       (let outer_X (Subst      (InIf true  a          outer_ins) sub_arg_true X))
       (let inner_X (AddContext (InIf true  inner_pred sub_arg_false) X))
       (let inner_Y (AddContext (InIf false inner_pred sub_arg_false) Y))

       (let inner (If inner_pred sub_arg_false inner_X inner_Y))
       (union lhs (If a          outer_ins     outer_X inner  )))

       :ruleset switch_rewrite)

(rewrite (If (Const (Bool true)  ty ctx) ins thn els)
         (Subst ctx ins thn)
         :ruleset always-switch-rewrite)

(rewrite (If (Const (Bool false) ty ctx) ins thn els)
         (Subst ctx ins els)
         :ruleset always-switch-rewrite)

; Simple rewrites that don't do a ton with control flow.

(ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int 0) ty ctx) e) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 0) ty ctx)) (Const (Int 0) ty ctx) :ruleset peepholes)
(rewrite (Bop (Mul) (Const (Int 1) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Mul) e (Const (Int 1) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int 0) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Add) e (Const (Int 0) ty ctx) ) e :ruleset peepholes)

(rewrite (Bop (Mul) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (* i j)) ty ctx) :ruleset peepholes)
(rewrite (Bop (Add) (Const (Int j) ty ctx) (Const (Int i) ty ctx)) (Const (Int (+ i j)) ty ctx) :ruleset peepholes)

(rewrite (Bop (And) (Const (Bool true) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool true) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (And) (Const (Bool false) ty ctx) e) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (And) e (Const (Bool false) ty ctx)) (Const (Bool false) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool false) ty ctx) e) e :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool false) ty ctx)) e :ruleset peepholes)
(rewrite (Bop (Or) (Const (Bool true) ty ctx) e) (Const (Bool true) ty ctx) :ruleset peepholes)
(rewrite (Bop (Or) e (Const (Bool true) ty ctx)) (Const (Bool true) ty ctx) :ruleset peepholes)


(datatype IntOrInfinity
    (Infinity)
    (NegInfinity)
    (I i64))

(function MaxIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MaxIntOrInfinity (Infinity) _) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity _ (Infinity)) (Infinity) :ruleset always-run)
(rewrite (MaxIntOrInfinity (NegInfinity) x) x :ruleset always-run)
(rewrite (MaxIntOrInfinity x (NegInfinity)) x :ruleset always-run)
(rewrite (MaxIntOrInfinity (I x) (I y)) (I (max x y)) :ruleset always-run)

(function MinIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (MinIntOrInfinity (NegInfinity) _) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity _ (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (MinIntOrInfinity (Infinity) x) x :ruleset always-run)
(rewrite (MinIntOrInfinity x (Infinity)) x :ruleset always-run)
(rewrite (MinIntOrInfinity (I x) (I y)) (I (min x y)) :ruleset always-run)

(function AddIntOrInfinity (IntOrInfinity IntOrInfinity) IntOrInfinity)
(rewrite (AddIntOrInfinity (Infinity) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (Infinity) (I _)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (Infinity)) (Infinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (NegInfinity) (I _)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I _) (NegInfinity)) (NegInfinity) :ruleset always-run)
(rewrite (AddIntOrInfinity (I x) (I y)) (I (+ x y)) :ruleset always-run)

(datatype IntInterval (MkIntInterval IntOrInfinity IntOrInfinity))

(function UnionIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (UnionIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MinIntOrInfinity lo1 lo2) (MaxIntOrInfinity hi1 hi2))
         :ruleset always-run)

(function IntersectIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (IntersectIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (MaxIntOrInfinity lo1 lo2) (MinIntOrInfinity hi1 hi2))
         :ruleset always-run)

(function AddIntInterval (IntInterval IntInterval) IntInterval)
(rewrite (AddIntInterval (MkIntInterval lo1 hi1) (MkIntInterval lo2 hi2))
         (MkIntInterval (AddIntOrInfinity lo1 lo2)
                        (AddIntOrInfinity hi1 hi2))
         :ruleset always-run)


(datatype List<i64+IntInterval>
  (Nil-List<i64+IntInterval>)
  (Cons-List<i64+IntInterval> i64 IntInterval List<i64+IntInterval>))

(function Length-List<i64+IntInterval> (List<i64+IntInterval>) i64)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((set (Length-List<i64+IntInterval> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl))
       (= l (Length-List<i64+IntInterval> tl)))
      ((set (Length-List<i64+IntInterval> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Nil-List<i64+IntInterval>)))
      ((IsEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(relation IsNonEmpty-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= x (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((IsNonEmpty-List<i64+IntInterval> x))
      :ruleset always-run)

(function RevConcat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (RevConcat-List<i64+IntInterval> (Nil-List<i64+IntInterval>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<i64+IntInterval> (Cons-List<i64+IntInterval> hd0 hd1 tl) l)
         (RevConcat-List<i64+IntInterval> tl (Cons-List<i64+IntInterval> hd0 hd1 l))
         :ruleset always-run)

(function Rev-List<i64+IntInterval> (List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Rev-List<i64+IntInterval> m)
         (RevConcat-List<i64+IntInterval> m (Nil-List<i64+IntInterval>))
         :ruleset always-run)

(function Concat-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval> :cost 1000)
(rewrite (Concat-List<i64+IntInterval> x y)
         (RevConcat-List<i64+IntInterval> (Rev-List<i64+IntInterval> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<i64+IntInterval> (List<i64+IntInterval>))
(relation SuffixAt-List<i64+IntInterval> (List<i64+IntInterval> i64 List<i64+IntInterval>))
(relation At-List<i64+IntInterval> (List<i64+IntInterval> i64 i64 IntInterval))
(rule ((DemandAt-List<i64+IntInterval> x))
      ((SuffixAt-List<i64+IntInterval> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<i64+IntInterval> x i (Cons-List<i64+IntInterval> hd0 hd1 tl)))
      ((SuffixAt-List<i64+IntInterval> x (+ i 1) tl)
       (At-List<i64+IntInterval> x i hd0 hd1))
      :ruleset always-run)

(function Union-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (function UnionHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Union-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (UnionHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; both m1 and m2 empty
  (rewrite (UnionHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)
  ; take from m1 when m2 empty and vice versa
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      res)
    (UnionHelper-List<i64+IntInterval>
      (Nil-List<i64+IntInterval>)
      tl
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)
  (rewrite
    (UnionHelper-List<i64+IntInterval>
      (Cons-List<i64+IntInterval> hd0 hd1 tl)
      (Nil-List<i64+IntInterval>)
      res)
    (UnionHelper-List<i64+IntInterval>
      tl
      (Nil-List<i64+IntInterval>)
      (Cons-List<i64+IntInterval> hd0 hd1 res))
    :ruleset always-run)

  ; when both nonempty and smallest key different, take smaller key
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 l2 (Cons-List<i64+IntInterval> k1 a1 res))))
        :ruleset always-run)
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f
           (UnionHelper-List<i64+IntInterval> l1 tl2 (Cons-List<i64+IntInterval> k2 b1 res))))
        :ruleset always-run)

  ; when shared smallest key, union interval
  (rule ((= f (UnionHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (UnionHelper-List<i64+IntInterval> tl1 tl2
             (Cons-List<i64+IntInterval> k (UnionIntInterval a1 b1) res))))
        :ruleset always-run)

(function Intersect-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  ; The third argument of the helper is a WIP result map.
  ; Invariant: keys of the result map are not present in the first two and are in descending order
  (function IntersectHelper-List<i64+IntInterval> (List<i64+IntInterval> List<i64+IntInterval> List<i64+IntInterval>) List<i64+IntInterval>)
  (rewrite (Intersect-List<i64+IntInterval> m1 m2)
           (Rev-List<i64+IntInterval> (IntersectHelper-List<i64+IntInterval> m1 m2 (Nil-List<i64+IntInterval>)))
           :ruleset always-run)

  ; m1 or m2 empty
  (rewrite (IntersectHelper-List<i64+IntInterval> (Nil-List<i64+IntInterval>) m2 res)
           res
           :ruleset always-run)
  (rewrite (IntersectHelper-List<i64+IntInterval> m1 (Nil-List<i64+IntInterval>) res)
           res
           :ruleset always-run)

  ; when both nonempty and smallest key different, drop smaller key
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k1 k2))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k1 a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k2 b1 tl2))
         (< k2 k1))
        ((union f (IntersectHelper-List<i64+IntInterval> tl1 l2 res)))
        :ruleset always-run)

(datatype MyBool (MyTrue) (MyFalse))

(function IntIntervalValid (IntInterval) MyBool)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyTrue)
         :when ((<= lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (I lo) (I hi)))
         (MyFalse)
         :when ((> lo hi))
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval (NegInfinity) _))
         (MyTrue)
         :ruleset always-run)
(rewrite (IntIntervalValid (MkIntInterval _ (Infinity)))
         (MyTrue)
         :ruleset always-run)

(function ConsIfNonEmpty (i64 IntInterval List<i64+IntInterval>)
          List<i64+IntInterval>
          :cost 100)
(rule ((ConsIfNonEmpty k v tl))
      ((IntIntervalValid v))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyTrue) (IntIntervalValid v)))
      ((union f (Cons-List<i64+IntInterval> k v tl)))
      :ruleset always-run)
(rule ((= f (ConsIfNonEmpty k v tl))
       (= (MyFalse) (IntIntervalValid v)))
      ((union f tl))
      :ruleset always-run)

  ; when shared smallest key, intersect interval
  (rule ((= f (IntersectHelper-List<i64+IntInterval> l1 l2 res))
         (= l1 (Cons-List<i64+IntInterval> k a1 tl1))
         (= l2 (Cons-List<i64+IntInterval> k b1 tl2)))
        ((union f
           (IntersectHelper-List<i64+IntInterval> tl1 tl2
             (ConsIfNonEmpty k (IntersectIntInterval a1 b1) res))))
        :ruleset always-run)

(function AddIntIntervalToAll (IntInterval List<i64+IntInterval>)
                              List<i64+IntInterval>)
(rewrite (AddIntIntervalToAll _ (Nil-List<i64+IntInterval>))
         (Nil-List<i64+IntInterval>)
         :ruleset always-run)
(rewrite (AddIntIntervalToAll x (Cons-List<i64+IntInterval> allocid offset tl))
         (Cons-List<i64+IntInterval> allocid (AddIntInterval x offset)
           (AddIntIntervalToAll x tl))
         :ruleset always-run)

(datatype PtrPointees
  (PointsTo List<i64+IntInterval>)
  (PointsAnywhere))

(function AddIntIntervalToPtrPointees (IntInterval PtrPointees) PtrPointees)
(rewrite (AddIntIntervalToPtrPointees interval (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (AddIntIntervalToPtrPointees interval (PointsTo l))
         (PointsTo (AddIntIntervalToAll interval l))
         :ruleset always-run)

(function Union-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Union-PtrPointees (PointsAnywhere) _)
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees _ (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (Union-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Union-List<i64+IntInterval> x y))
         :ruleset always-run)
(function Intersect-PtrPointees (PtrPointees PtrPointees) PtrPointees)
(rewrite (Intersect-PtrPointees (PointsAnywhere) x)
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees x (PointsAnywhere))
         x
         :ruleset always-run)
(rewrite (Intersect-PtrPointees (PointsTo x) (PointsTo y))
         (PointsTo (Intersect-List<i64+IntInterval> x y))
         :ruleset always-run)

(relation PointsNowhere-PtrPointees (PtrPointees))
(rule ((= f (PointsTo x))
       (IsEmpty-List<i64+IntInterval> x))
      ((PointsNowhere-PtrPointees f))
      :ruleset always-run)


(datatype List<PtrPointees>
  (Nil-List<PtrPointees>)
  (Cons-List<PtrPointees> PtrPointees List<PtrPointees>))

(function Length-List<PtrPointees> (List<PtrPointees>) i64)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset always-run)
(rule ((= x (Nil-List<PtrPointees>)))
      ((set (Length-List<PtrPointees> x) 0))
      :ruleset memory-helpers)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (= l (Length-List<PtrPointees> tl)))
      ((set (Length-List<PtrPointees> x) (+ l 1)))
      :ruleset memory-helpers)

(relation IsEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((IsEmpty-List<PtrPointees> x))
      :ruleset always-run)

(relation IsNonEmpty-List<PtrPointees> (List<PtrPointees>))
(rule ((= x (Cons-List<PtrPointees> hd0 tl)))
      ((IsNonEmpty-List<PtrPointees> x))
      :ruleset always-run)

(function RevConcat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (RevConcat-List<PtrPointees> (Nil-List<PtrPointees>) l)
         l
         :ruleset always-run)
(rewrite (RevConcat-List<PtrPointees> (Cons-List<PtrPointees> hd0 tl) l)
         (RevConcat-List<PtrPointees> tl (Cons-List<PtrPointees> hd0 l))
         :ruleset always-run)

(function Rev-List<PtrPointees> (List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Rev-List<PtrPointees> m)
         (RevConcat-List<PtrPointees> m (Nil-List<PtrPointees>))
         :ruleset always-run)

(function Concat-List<PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Concat-List<PtrPointees> x y)
         (RevConcat-List<PtrPointees> (Rev-List<PtrPointees> x) y)
         :ruleset always-run)

; SuffixAt and At must be demanded, otherwise these are O(N^2)
(relation DemandAt-List<PtrPointees> (List<PtrPointees>))
(relation SuffixAt-List<PtrPointees> (List<PtrPointees> i64 List<PtrPointees>))
(relation At-List<PtrPointees> (List<PtrPointees> i64 PtrPointees))
(rule ((DemandAt-List<PtrPointees> x))
      ((SuffixAt-List<PtrPointees> x 0 x))
      :ruleset always-run)
(rule ((SuffixAt-List<PtrPointees> x i (Cons-List<PtrPointees> hd0 tl)))
      ((SuffixAt-List<PtrPointees> x (+ i 1) tl)
       (At-List<PtrPointees> x i hd0))
      :ruleset always-run)

(relation All<PointsNowhere-PtrPointees> (List<PtrPointees>))
(rule ((= x (Nil-List<PtrPointees>)))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)
(rule ((= x (Cons-List<PtrPointees> hd0 tl))
       (PointsNowhere-PtrPointees hd0)
       (All<PointsNowhere-PtrPointees> tl))
      ((All<PointsNowhere-PtrPointees> x))
      :ruleset always-run)



(function Zip<Union-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Union-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Union-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Union-PtrPointees x0 y0)
            (Zip<Union-PtrPointees> tl1 tl2))
         :when ((= (Length-List<PtrPointees> tl1) (Length-List<PtrPointees> tl2)))
         :ruleset always-run)

(function Zip<Intersect-PtrPointees> (List<PtrPointees> List<PtrPointees>) List<PtrPointees> :cost 1000)
(rewrite (Zip<Intersect-PtrPointees> (Nil-List<PtrPointees>) (Nil-List<PtrPointees>))
         (Nil-List<PtrPointees>)
         :ruleset always-run)
(rewrite (Zip<Intersect-PtrPointees>
           (Cons-List<PtrPointees> x0 tl1)
           (Cons-List<PtrPointees> y0 tl2))
         (Cons-List<PtrPointees>
            (Intersect-PtrPointees x0 y0)
            (Zip<Intersect-PtrPointees> tl1 tl2))
         :ruleset always-run)


(sort ExprSetPrim (Set Expr))

(datatype ExprSet (ES ExprSetPrim))

(function ExprSet-intersect (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-intersect (ES set1) (ES set2)) (ES (set-intersect set1 set2))
         :ruleset memory-helpers)
(function ExprSet-union (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-union (ES set1) (ES set2)) (ES (set-union set1 set2))
         :ruleset memory-helpers)
(relation ExprSet-contains (ExprSet Expr))
(rule ((ES set1) (set-contains set1 x))
      ((ExprSet-contains (ES set1) x))
      :ruleset memory-helpers)
(function ExprSet-insert (ExprSet Expr) ExprSet)
(rewrite (ExprSet-insert (ES set1) x)
         (ES (set-insert set1 x))
         :ruleset memory-helpers)
(function ExprSet-length (ExprSet) i64)
(rewrite (ExprSet-length (ES set1)) (set-length set1) :ruleset memory-helpers)

; ============================
; Pointees
; ============================


; List<i64+IntInterval> is used as an association list; the i64 keys
; (corresponding to alloc ids) are always unique and sorted, the IntInterval
; values correspond to offset ranges.
;
; (TuplePointsTo [{0->[4,5], 1->[0,0]}, {0->[0,0]}])
; indicates a tuple with two components.
; - The first component might point to Alloc 0 at offsets 4 or 5,
;   or Alloc 1 at offset 0
; - The second component points to Alloc 0 at offset 0
(datatype Pointees
          (TuplePointsTo List<PtrPointees>)
          (PtrPointsTo PtrPointees))

(function UnwrapPtrPointsTo (Pointees) PtrPointees)
(rewrite (UnwrapPtrPointsTo (PtrPointsTo x))
         x
         :ruleset memory-helpers)
(function UnwrapTuplePointsTo (Pointees) List<PtrPointees>)
(rewrite (UnwrapTuplePointsTo (TuplePointsTo x))
         x
         :ruleset memory-helpers)

(relation PointsNowhere (Pointees))
(rule ((= f (PtrPointsTo x))
       (PointsNowhere-PtrPointees x))
      ((PointsNowhere f))
      :ruleset memory-helpers)
(rule ((= f (TuplePointsTo l))
       (All<PointsNowhere-PtrPointees> l))
      ((PointsNowhere f))
      :ruleset memory-helpers)

(function UnionPointees (Pointees Pointees) Pointees)
(rewrite (UnionPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Union-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (UnionPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Union-PtrPointees> x y))
         :when ((= (Length-List<PtrPointees> x) (Length-List<PtrPointees> y)))
         :ruleset memory-helpers)
(function IntersectPointees (Pointees Pointees) Pointees)
(rewrite (IntersectPointees (PtrPointsTo x) (PtrPointsTo y))
         (PtrPointsTo (Intersect-PtrPointees x y))
         :ruleset memory-helpers)
(rewrite (IntersectPointees (TuplePointsTo x) (TuplePointsTo y))
         (TuplePointsTo (Zip<Intersect-PtrPointees> x y))
         :ruleset memory-helpers)

(function GetPointees (Pointees i64) Pointees)
(rule ((= f (GetPointees (TuplePointsTo l) i))
       (At-List<PtrPointees> l i x))
      ((union f (PtrPointsTo x)))
      :ruleset memory-helpers)

(function PointeesDropFirst (Pointees) Pointees)
(rewrite (PointeesDropFirst (TuplePointsTo (Cons-List<PtrPointees> hd tl)))
         (TuplePointsTo tl)
         :ruleset memory-helpers)

; ============================
; Resolved
; ============================

; Resolved checks if an e-class contains a term containing only constructors and
; primitives; i.e. whether equality is decideable
(relation Resolved-IntOrInfinity (IntOrInfinity))
(rule ((= f (I _)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (Infinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)
(rule ((= f (NegInfinity)))
      ((Resolved-IntOrInfinity f))
      :ruleset memory-helpers)

(relation Resolved-IntInterval (IntInterval))
(rule ((= f (MkIntInterval lo hi))
       (Resolved-IntOrInfinity lo)
       (Resolved-IntOrInfinity hi))
      ((Resolved-IntInterval f))
      :ruleset memory-helpers)

(relation Resolved-List<i64+IntInterval> (List<i64+IntInterval>))
(rule ((= f (Nil-List<i64+IntInterval>)))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<i64+IntInterval> allocid offsets tl))
       (Resolved-List<i64+IntInterval> tl)
       (Resolved-IntInterval offsets))
      ((Resolved-List<i64+IntInterval> f))
      :ruleset memory-helpers)

(relation Resolved-PtrPointees (PtrPointees))
(rule ((= f (PointsAnywhere)))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)
(rule ((= f (PointsTo x))
       (Resolved-List<i64+IntInterval> x))
      ((Resolved-PtrPointees f))
      :ruleset memory-helpers)

(relation Resolved-List<PtrPointees> (List<PtrPointees>))
(rule ((= f (Nil-List<PtrPointees>)))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)
(rule ((= f (Cons-List<PtrPointees> hd tl))
       (Resolved-List<PtrPointees> tl)
       (Resolved-PtrPointees hd))
      ((Resolved-List<PtrPointees> f))
      :ruleset memory-helpers)

(relation Resolved-Pointees (Pointees))
(rule ((= f (TuplePointsTo x))
       (Resolved-List<PtrPointees> x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)
(rule ((= f (PtrPointsTo x))
       (Resolved-PtrPointees x))
      ((Resolved-Pointees f))
      :ruleset memory-helpers)


;;;;;

(function BaseTypeToPtrPointees (BaseType) PtrPointees :cost 100)
(rewrite (BaseTypeToPtrPointees (PointerT _))
         (PointsAnywhere)
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (IntT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (StateT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)
(rewrite (BaseTypeToPtrPointees (BoolT))
         (PointsTo (Nil-List<i64+IntInterval>))
         :ruleset memory-helpers)

(function TypeListToList<PtrPointees> (TypeList) List<PtrPointees> :cost 1000)
(rewrite (TypeListToList<PtrPointees> (TNil))
         (Nil-List<PtrPointees>)
         :ruleset memory-helpers)
(rewrite (TypeListToList<PtrPointees> (TCons hd tl))
         (Cons-List<PtrPointees>
            (BaseTypeToPtrPointees hd)
            (TypeListToList<PtrPointees> tl))
         :ruleset memory-helpers)

(function TypeToPointees (Type) Pointees :cost 1000)
(rewrite (TypeToPointees (TupleT tylist))
         (TuplePointsTo (TypeListToList<PtrPointees> tylist))
         :ruleset memory-helpers)
(rewrite (TypeToPointees (Base basety))
         (PtrPointsTo (BaseTypeToPtrPointees basety))
         :ruleset memory-helpers)

; ============================
; Update PointerishType
; ============================

(relation PointerishType (Type))
(relation PointerishTypeList (TypeList))

(rule ((= f (Base (PointerT ty))))
      ((PointerishType f))
      :ruleset always-run)

(rule ((= f (TCons (PointerT ty) tl)))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TCons hd tl))
       (PointerishTypeList tl))
      ((PointerishTypeList f))
      :ruleset always-run)

(rule ((= f (TupleT l))
       (PointerishTypeList l))
      ((PointerishType f))
      :ruleset always-run)

; ============================
; Update PointsToCells
; ============================

;                             arg pointees  result pointees
(function PointsToCells (Expr Pointees)     Pointees :unextractable)

; Top-level demand
(rule ((Function name in-ty out-ty body))
      ((PointsToCells body (TypeToPointees in-ty)))
      :ruleset memory-helpers)

; Demand PointsToCells along state edge and pointer-typed values
(rule ((PointsToCells (Bop (Print) e state) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Load) e state) ap))
      ((PointsToCells e ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Top (Write) ptr val state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Alloc id sz state ty) ap))
      ((PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Bop (Free) ptr state) ap))
      ((PointsToCells ptr ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Get x i) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Concat x y) ap))
      ((PointsToCells x ap)
       (PointsToCells y ap))
      :ruleset memory-helpers)
(rule ((PointsToCells (Single x) ap))
      ((PointsToCells x ap))
      :ruleset memory-helpers)

; Compute and propagate PointsToCells
(rewrite (PointsToCells concat-x-y aps)
         (TuplePointsTo (Concat-List<PtrPointees>
           (UnwrapTuplePointsTo (PointsToCells x aps))
           (UnwrapTuplePointsTo (PointsToCells y aps))))
         :when ((= concat-x-y (Concat x y))
                (HasType concat-x-y ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells get-x-i aps)
         (GetPointees (PointsToCells x aps) i)
         :when ((= get-x-i (Get x i))
                (HasType get-x-i ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells (Single x) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (UnwrapPtrPointsTo (PointsToCells x aps))
             (Nil-List<PtrPointees>)))
         :when ((HasType (Single x) ty) (PointerishType ty))
         :ruleset memory-helpers)

(rewrite (PointsToCells (Arg ty_ ctx) aps)
         aps
         :when ((HasType (Arg ty_ ctx) ty) (PointerishType ty))
         :ruleset memory-helpers)

; Allow non-pointer types to resolve
(rule ((PointsToCells x aps)
       (HasType x ty))
      ((TypeToPointees ty))
      :ruleset memory-helpers)
(rule ((= f (PointsToCells x aps))
       (HasType x ty)
       (= pointees (TypeToPointees ty))
       (PointsNowhere pointees))
      ((union f pointees))
      :ruleset memory-helpers)

(rewrite (PointsToCells (Bop (PtrAdd) x e) aps)
         (PtrPointsTo
           (AddIntIntervalToPtrPointees
             (MkIntInterval (I lo) (I hi))
             (UnwrapPtrPointsTo (PointsToCells x aps))))
         :when ((= (IntB lo) (lo-bound e))
                (= (IntB hi) (hi-bound e)))
         :ruleset memory-helpers)

(rewrite (PointsToCells (If c inputs t e) aps)
         (UnionPointees
           (PointsToCells t (PointsToCells inputs aps))
           (PointsToCells e (PointsToCells inputs aps)))
         :when ((HasType (If c inputs t e) ty) (PointerishType ty))
         :ruleset memory)

(rewrite (PointsToCells (Alloc id sz state ty) aps)
         (TuplePointsTo
           (Cons-List<PtrPointees>
             (PointsTo
               (Cons-List<i64+IntInterval>
                 id
                 (MkIntInterval (I 0) (I 0))
                 (Nil-List<i64+IntInterval>)))
             (Cons-List<PtrPointees>
               (PointsTo (Nil-List<i64+IntInterval>)) ; state output points to nothing
               (Nil-List<PtrPointees>))))
         :ruleset memory-helpers)

; arg pointees * loop in * loop out * i64 -> result pointees
(function PointsToCellsAtIter (Pointees Expr Expr i64) Pointees)

; compute first two
(rule ((= e (DoWhile inputs pred-body))
       (PointsToCells e aps))
      ((set (PointsToCellsAtIter aps inputs pred-body 0)
            (PointsToCells inputs aps))
       (set (PointsToCellsAtIter aps inputs pred-body 1)
            (UnionPointees
              (PointsToCellsAtIter aps inputs pred-body 0)
              (PointeesDropFirst
                (PointsToCells pred-body (PointsToCellsAtIter aps inputs pred-body 0))))))
      :ruleset memory-helpers)

; avoid quadratic query
(function succ (i64) i64 :unextractable)
(rule ((PointsToCellsAtIter aps inputs pred-body i))
      ((set (succ i) (+ i 1)))
      :ruleset memory-helpers)

; Note that this rule is bounded by ruleset memory
(rule ((= pointees0 (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees1 (PointsToCellsAtIter aps inputs pred-body (succ i)))
       (Resolved-Pointees pointees0)
       (Resolved-Pointees pointees1)
       (!= pointees0 pointees1))
      ((set (PointsToCellsAtIter aps inputs pred-body (+ i 2))
            (UnionPointees
              pointees1
              (PointeesDropFirst
                (PointsToCells pred-body pointees1)))))
      :ruleset memory)

(rule ((= pointees (PointsToCellsAtIter aps inputs pred-body i))
       (= pointees (PointsToCellsAtIter aps inputs pred-body (succ i))))
      ((set (PointsToCells (DoWhile inputs pred-body) aps)
            pointees))
      :ruleset memory)

(rule ((PtrPointsTo (PointsTo l)))
      ((DemandAt-List<i64+IntInterval> l))
      :ruleset memory-helpers)
(rule ((TuplePointsTo l))
      ((DemandAt-List<PtrPointees> l))
      :ruleset memory-helpers)

; ============================
; Update DontAlias
; ============================

(relation DemandDontAlias (Expr Expr Pointees))
;                    pointer, pointer, arg pointees
(relation DontAlias (Expr Expr Pointees))


(rule ((DemandDontAlias ptr1 ptr2 arg-pointees)
       (BodyContainsExpr body ptr1)
       (BodyContainsExpr body ptr2)
       (HasType ptr1 (Base (PointerT ty)))
       (HasType ptr2 (Base (PointerT ty)))
       (= pointees1 (PointsToCells ptr1 arg-pointees))
       (= pointees2 (PointsToCells ptr2 arg-pointees)))
      ((IntersectPointees pointees1 pointees2))
      :ruleset memory-helpers)

(rule ((PointsNowhere
         (IntersectPointees
           (PointsToCells ptr1 arg-pointees)
           (PointsToCells ptr2 arg-pointees))))
      ((DontAlias ptr1 ptr2 arg-pointees))
      :ruleset memory-helpers)

; ============================
; Update PointsToExpr
; ============================

;                       program point, pointer
(function PointsToExpr (Expr           Expr) Expr :unextractable)

; After a load, the ptr points to the loaded value
(rule ((= f (Bop (Load) ptr state)))
      ((set (PointsToExpr (Get f 1) ptr) (Get f 0)))
      :ruleset memory-helpers)

; If we load and we already know what the pointer points to
; TODO this rule breaks the weakly linear invariant
; when a previous load may not be on the path
;(rule ((= e (Bop (Load) addr state))
;       (= v (PointsToExpr state addr)))
;      ((union (Get e 0) v)
;       (union (Get e 1) state))
;       :ruleset memory-helpers)

; Loads and prints don't affect what what pointers already point to
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Load) any-addr state)))
      ((let new-state (Get e 1))
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)
(rule ((= f (PointsToExpr state addr))
       (= e (Bop (Print) any-val state)))
      ((let new-state e)
       (union (PointsToExpr new-state addr) f))
      :ruleset memory-helpers)

; Writes don't affect what a pointer points to if it writes to another pointer
; guaranteed to not alias.
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr)))
      ((DemandDontAlias addr otheraddr (TypeToPointees argty)))
      :ruleset memory-helpers)
(rule ((= e (Top (Write) addr data state))
       (HasArgType addr argty)
       (= otherdata (PointsToExpr state otheraddr))
       (DontAlias addr otheraddr (TypeToPointees argty)))
      ((set (PointsToExpr e otheraddr) otherdata))
      :ruleset memory-helpers)

; For a write, mark the given expression as containing `data`.
(rule ((= e (Top (Write) addr data state)))
      ((union (PointsToExpr e addr) data))
      :ruleset memory-helpers)

; ============================
; Update CellHasValues (currently unused)
; ============================

; ;                       program point, cell
; (function CellHasValues (Expr i64) ExprSet :merge (ExprSet-intersect old new))

; ; At the time of an alloc, a cell doesn't contain any values
; (rule ((= f (Alloc id amt state ty)))
      ; ((set (CellHasValues (Get f 1) id) (ES (set-empty))))
      ; :ruleset memory-helpers)

; ; These two rules find (Write ptr val state) where
; ; ptr points to cells given no assumptions about where (Arg) points.
; ; TODO: make sensitive to offsets
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty))
      ; ((TypeToPointees argty))
      ; :ruleset memory-helpers)
; (rule ((= e (Top (Write) ptr val state))
       ; (HasArgType ptr argty)
       ; (= (PtrPointsTo (PointsTo cells)) (PointsToCells ptr (TypeToPointees argty)))
       ; (At-List<i64+IntInterval> cells any-idx alloc-id offsets)
       ; (= vals (CellHasValues state cell)))
      ; ((set (CellHasValues e cell) (ExprSet-insert vals val)))
      ; :ruleset memory-helpers)

;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :unextractable :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :unextractable :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list)
       (= loop (DoWhile inputs pred_out)))
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)


(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch/pred is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)


(function hoisted-loop (Expr Expr) bool :unextractable :merge (or old new) )
(rule ((= loop (DoWhile in pred_out)))
      ((set (hoisted-loop in pred_out) false)) :ruleset always-run)

(function InExtendedLoop (Expr Expr Expr) Assumption)

;; mock function
(ruleset loop-inv-motion)

(rule ((boundary-Expr loop inv)
       (> (Expr-size inv) 1)
       ;; TODO: replace Expr-size when cost model is ready
       (= loop (DoWhile in pred_out))
       ;; the outter assumption of the loop
       (ContextOf loop loop_ctx)
       (HasType in in_type)
       (HasType inv inv_type)
       (= inv_type (Base base_inv_ty))
       (= in_type (TupleT tylist))
       (= false (hoisted-loop in pred_out))
       (= len (tuple-length in)))
      ((let new_input (Concat in (Single (Subst loop_ctx in inv))))
       (let new_input_type (TupleT (TLConcat tylist (TCons base_inv_ty (TNil)))))
       ;; create an virtual assume node, union it with actuall InLoop later
       (let assum (InExtendedLoop in pred_out new_input))
       (let new_out_branch (Get (Arg new_input_type assum) len))
       ;; this two subst only change arg to arg with new type
       (let substed_pred_out (Subst assum (Arg new_input_type assum) pred_out))
       (let inv_in_new_loop (Subst assum (Arg new_input_type assum) inv))
       (let new_pred_out (Concat substed_pred_out (Single new_out_branch)))

       (let new_loop (DoWhile new_input new_pred_out))
       (union assum (InLoop new_input new_pred_out))
       (union inv_in_new_loop new_out_branch)
       (let wrapper (SubTuple new_loop 0 len))
       (union loop wrapper)
       (subsume (DoWhile in pred_out))
       ;; don't hoist same loop again
       (set (hoisted-loop in pred_out) true)
      )
       :ruleset loop-inv-motion)


(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Const _n _ty _ctx)))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Get (Arg ty ctx) i))
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out (+ i 1))))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Function _name _tyin _tyout _out))

       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Top _op _x _y _z))
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) (= true (is-inv-Expr loop _z))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Bop _op _x _y)) (BinaryOpIsPure _op)
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Uop _op _x)) (UnaryOpIsPure _op)
       (= true (is-inv-Expr loop _x))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Get _tup _i))
       (= true (is-inv-Expr loop _tup))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Concat _x _y))
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Single _x))
       (= true (is-inv-Expr loop _x))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Switch _pred _inputs _branches))
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _inputs)) (= true (is-inv-ListExpr loop _branches))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (If _pred _input _then _else))
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _input))
       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (DoWhile _in _pred-and-output))
       (= true (is-inv-Expr loop _in))
       (ExprIsPure expr))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Call _func _arg))
       (= true (is-inv-Expr loop _arg))
       (ExprIsPure expr))
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr)
       (= loop (DoWhile in out))
       (= expr (Empty _ty _ctx))

       )
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)


(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Top _op _x _y _z))
       (= expr1 _x))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Top _op _x _y _z))
       (= expr1 _y))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Top _op _x _y _z))
       (= expr1 _z))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Bop _op _x _y))
       (= expr1 _x))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Bop _op _x _y))
       (= expr1 _y))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Uop _op _x))
       (= expr1 _x))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Concat _x _y))
       (= expr1 _x))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Concat _x _y))
       (= expr1 _y))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Single _x))
       (= expr1 _x))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Switch _pred _inputs _branches))
       (= expr1 _pred))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Switch _pred _inputs _branches))
       (= expr1 _inputs))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (If _pred _input _then _else))
       (= expr1 _pred))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (If _pred _input _then _else))
       (= expr1 _input))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (DoWhile _in _pred-and-output))
       (= expr1 _in))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Call _func _arg))
       (= expr1 _arg))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)


(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Alloc _id _e _state _ty))
       (= expr1 _e))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)

(rule ((= true (is-inv-Expr loop expr1))
       (= false (is-inv-Expr loop expr2))
       (= expr2 (Alloc _id _e _state _ty))
       (= expr1 _state))
       ((boundary-Expr loop expr1)) :ruleset boundary-analysis)
;; Some simple simplifications of loops
(ruleset loop-simplify)

(rewrite
 (DoWhile (Arg ty ctx)
  (Concat (Single (Const (Bool false) ty ctx2))
    (Single (Const constant ty ctx2))))
 (Single (Const constant ty ctx))
 :ruleset loop-simplify)
;; Some simple simplifications of loops
(ruleset loop-unroll)
(ruleset loop-peel)
(ruleset loop-iters-analysis)

;;                      inputs, outputs -> number of iterations
;; The minimum possible guess is 1 because of do-while loops
;; TODO: dead loop deletion can turn loops with a false condition to a body
(function LoopNumItersGuess (Expr Expr) i64 :merge (max 1 (min old new)))

;; by default, guess that all loops run 1000 times
(rule ((DoWhile inputs outputs))
      ((set (LoopNumItersGuess inputs outputs) 1000))
      :ruleset loop-iters-analysis)

;; For a loop that is false, its num iters is 1
(rule
  ((= loop (DoWhile inputs outputs))
   (= (Const (Bool false) ty ctx) (Get outputs 0)))
  ((set (LoopNumItersGuess inputs outputs) 1))
:ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated before checking pred
;; TODO: we could make it work for decrementing loops
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by some constant each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while next_counter less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (/ (- end_constant start_const) increment))
  )
  :ruleset loop-iters-analysis)

;; Figure out number of iterations for a loop with constant bounds and initial value
;; and i is updated after checking pred
(rule
  ((= lhs (DoWhile inputs outputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   (= body-arg (Get (Arg _ty _ctx) counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by a constant each loop
   (= next_counter (Bop (Add) body-arg
                              (Const (Int increment) _ty2 _ctx2)))
   (> increment 0)
   ;; while this counter less than end_constant
   (= pred (Bop (LessThan) body-arg
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; end constant is at least start constant
   (>= end_constant start_const)
  )
  (
    (set (LoopNumItersGuess inputs outputs) (+ (/ (- end_constant start_const) increment) 1))
  )
  :ruleset loop-iters-analysis)

;; loop peeling rule
;; Only peel loops that we know iterate < 3 times
(function LoopPeeledPlaceholder (Expr) Assumption :unextractable)
(rule
 ((= lhs (DoWhile inputs outputs))
  (ContextOf lhs ctx)
  (HasType inputs inputs-ty)
  (= outputs-len (tuple-length outputs))
  (= old_cost (LoopNumItersGuess inputs outputs))
  (< old_cost 3)
  )
 (
  (let executed-once
    (Subst ctx inputs outputs))
  (let executed-once-body
     (SubTuple executed-once 1 (- outputs-len 1)))
  (let then-ctx
    (InIf true (Get executed-once 0) executed-once-body))
  (let else-ctx
    (InIf false (Get executed-once 0) executed-once-body))

  (let new-loop-arg
    (Arg inputs-ty then-ctx))
  (let new-loop-body
    (Subst (LoopPeeledPlaceholder lhs) new-loop-arg outputs))
  (union (InLoop new-loop-arg new-loop-body) (LoopPeeledPlaceholder lhs))

  (union lhs
    ;; check if we need to continue executing the loop
    (If (Get executed-once 0)
      executed-once-body ;; inputs are the body executed once
      (DoWhile new-loop-arg new-loop-body)
      (Arg inputs-ty else-ctx)))

  (set (LoopNumItersGuess new-loop-arg new-loop-body) (- old_cost 1))
  )
 :ruleset loop-peel)

;; unroll a loop with constant bounds and initial value
(rule
  ((= lhs (DoWhile inputs outputs))
   (= num-inputs (tuple-length inputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by one each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int 1) _ty2 _ctx2)))
   ;; while less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; start and end constant is a multiple of 4 and greater than start_const
   (> end_constant start_const)
   (= (% start_const 4) 0)
   (= (% end_constant 4) 0)
   (= old_cost (LoopNumItersGuess inputs outputs))
  )
  (
    (let one-iter (SubTuple outputs 1 num-inputs))
    (let unrolled
        (Subst (TmpCtx) one-iter
          (Subst (TmpCtx) one-iter
            (Subst (TmpCtx) one-iter
               outputs))))
    (union lhs
      (DoWhile inputs
        unrolled))
    (let actual-ctx (InLoop inputs unrolled))
    (union (TmpCtx) actual-ctx)

    (set (LoopNumItersGuess inputs unrolled) (/ old_cost 4))
    (delete (TmpCtx))
  )
  :ruleset loop-unroll)



(ruleset passthrough)


;; Pass through thetas
(rule ((= lhs (Get loop i))
        (= loop (DoWhile inputs pred-outputs))
        (= (Get pred-outputs (+ i 1)) (Get (Arg _ty _ctx) i))
        ;; only pass through pure types, since some loops don't terminate
        ;; so the state edge must pass through them
        (HasType lhs lhs_ty)
        (PureType lhs_ty)
        )
       ((union lhs (Get inputs i)))
       :ruleset passthrough)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (NonStateType lhs_ty))
      ((union lhs passed-through))
      :ruleset passthrough)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _ _ctx0))
       (= (Get branch1 i) (Const (Bool true) _ _ctx1)))
      ((union lhs pred))
      :ruleset passthrough)

;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= then-branch (Get then_ i))
       (= else-branch (Get else_ i))
       (= then-branch (Get (Arg arg_ty _then_ctx) j))
       (= else-branch (Get (Arg arg_ty _else_ctx) j))
       (HasType then-branch lhs_ty)
       (NonStateType lhs_ty))
      ((union (Get if i) (Get inputs j)))
      :ruleset passthrough)

; Pass through if state edge arguments
; To maintain the invariant, we have to union the other outputs with a pure if statement
(ruleset state-edge-passthrough)

(rule ((= outputs (If pred inputs then_ else_))

       (= (Get then_ i) (Get (Arg arg_ty then_ctx) j))
       (= (Get else_ i) (Get (Arg arg_ty else_ctx) j))

       (HasType (Get then_ i) (Base (StateT))))

      ((let lhs (Get outputs i))
       (let new_inputs (TupleRemoveAt inputs j))

       (let new_then_ctx (InIf true  pred new_inputs))
       (let new_else_ctx (InIf false pred new_inputs))

       (let old_then (TupleRemoveAt then_ i))
       (let old_else (TupleRemoveAt else_ i))

       (let new_then (DropAt new_then_ctx j old_then))
       (let new_else (DropAt new_else_ctx j old_else))

       (let old_outputs (TupleRemoveAt outputs i))
       (let new_if (If pred new_inputs new_then new_else))
       (union new_if old_outputs)

       (union lhs (Get inputs j))
       ;; Be careful not to subsume the original if statement immediately,
       ;;  since TupleRemoveAt still needs to match on it
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset state-edge-passthrough)

;; Pass through if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool true) _ _thenctx))
       (= (Get else_ i) (Const (Bool false) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) pred)
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; Pass through inverted if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool false) _ _thenctx))
       (= (Get else_ i) (Const (Bool true) _ _elsectx)))

      ((let new_then (TupleRemoveAt then_ i))
       (let new_else (TupleRemoveAt else_ i))
       (let new_if (If pred inputs new_then new_else))

       (union (Get           if i) (Uop (Not) pred))
       (union (TupleRemoveAt if i) new_if)
       (ToSubsumeIf pred inputs then_ else_))
      :ruleset passthrough)

;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c
(ruleset loop-strength-reduction)

; Finds invariants/constants within a body.
; Columns: body; value of invariant in inputs; value of invariant in outputs
;; Get the input and output value of an invariant, or constant int, within the loop
;;             loop in   out
(relation lsr-inv (Expr Expr Expr))

; TODO: there may be a bug with finding the invariant, or it just may not be extracted.
; Can make this work on loop_with_mul_by_inv and a rust test later.
; (rule (
;     (= loop (DoWhile inputs pred-and-body))
;     (= (Get outputs (+ i 1)) (Get (Arg arg-type assm) i)))
;     ((inv loop (Get inputs i) (Get (Arg arg-type assm) i))) :ruleset always-run)
(rule (
    (= loop (DoWhile inputs pred-and-body))
    (ContextOf inputs loop-input-ctx)
    (ContextOf pred-and-body loop-output-ctx)
    (= constant (Const c out-type loop-output-ctx))
    (HasArgType inputs in-type)
    )
    ((lsr-inv loop (Const c in-type loop-input-ctx) constant)) :ruleset always-run)

(rule
    (
        ;; Find loop
        (= old-loop (DoWhile inputs pred-and-outputs))
        (ContextOf pred-and-outputs loop-ctx)

        ; Find loop variable (argument that gets incremented with an invariant)
        (lsr-inv old-loop loop-incr-in loop-incr-out)
        ; Since the first el of pred-and-outputs is the pred, we need to offset i
        (= (Get pred-and-outputs (+ i 1)) (Bop (Add) (Get (Arg arg-type assm) i) loop-incr-out))

        ; Find invariant where input is same as output, or constant
        (lsr-inv old-loop c-in c-out)

        ; Find multiplication of loop variable and invariant
        (= old-mul (Bop (Mul) c-out (Get (Arg arg-type assm) i)))
        (ContextOf old-mul loop-ctx)

        (= arg-type (TupleT ty-list))
    )
    (
        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Bop (Mul) c-out loop-incr-out))

        ; n is index of our new, temporary variable d
        (let n (tuple-length inputs))

        ; Initial value of d is i * c
        (let d-init (Bop (Mul) c-in (Get inputs i)))

        ; Construct optimized theta
        ; new-inputs already has the correct context
        (let new-inputs (Concat inputs (Single d-init)))

        ; We need to create a new type, with one more input
        (let new-arg-ty (TupleT (TLConcat ty-list (TCons (IntT) (TNil)))))

        ; Value of d in loop. Add context to addend
        (let d-out (Bop (Add) (Get (Arg new-arg-ty (TmpCtx)) n)
                              (Subst (TmpCtx) (Arg new-arg-ty (TmpCtx)) addend)))

        ; build the old body, making sure to set the correct arg type and context
        (let new-body
          (Concat
            (Subst (TmpCtx) (Arg new-arg-ty (TmpCtx)) pred-and-outputs)
            (Single d-out)))

        (let new-loop (DoWhile new-inputs new-body))

        ; Now that we have the new loop, union the temporary context with the actual ctx
        (union (TmpCtx) (InLoop new-inputs new-body))

        ; Substitute d for the *i expression
        (let new-mul
            (Bop
                (Mul)
                (Subst (TmpCtx) (Arg new-arg-ty (TmpCtx)) c-out)
                (Get (Arg new-arg-ty (TmpCtx)) i)))
        (union (Get (Arg new-arg-ty (TmpCtx)) n) new-mul)

        ; Subsume the multiplication in the new loop to prevent
        ; from firing loop strength reduction again on the new loop
        (subsume
            (Bop
                (Mul)
                (Subst (TmpCtx) (Arg new-arg-ty (TmpCtx)) c-out)
                (Get (Arg new-arg-ty (TmpCtx)) i)))

        ; Project all but last
        (union old-loop (SubTuple new-loop 0 n))
        (delete (TmpCtx))
    )
    :ruleset loop-strength-reduction
)
(ruleset loop-multiply-motion)


;;Example:
;;
;;original:
;; int x = 0;
;; while (x < 3) {
;;   x += 1;
;; }
;; return x * 5;
;; optimized:
;;
;; int x = 0;
;; while (x < 15) {
;;     x += 5;
;; }
;; return x;
(rule ((= loop (DoWhile in pred_out))
       (= argi (Get (Arg ty ctx) i))
       (= inputs-len (tuple-length (Arg ty ctx)))
       ;; variable is incremented by constant each iteration
       (= (Get pred_out (+ i 1))
          (Bop (Add) argi (Const (Int c) ty ctx)))
       ;; check that it is less than n
       (= (Get pred_out 0)
          (Bop (LessThan) (Get pred_out (+ i 1))
                          (Const (Int n) ty ctx)))
       ;; overapproximate check that we won't overflow
       (< (+ n (+ c k)) 10000)

       ;; after the loop, we multiply by some constant
       (= res (Bop (Mul) (Get loop i) (Const (Int k) ty_outer ctx_outer)))
       (= ty (TupleT ty_list)))
      ( ;; new type
       (let new-arg-ty
         (TupleT (TLConcat ty_list (TCons (IntT) (TNil)))))
       ;; new inputs with i duplicated
       (let new-inputs (Concat in (Single (Get in i))))
       (let new-pred-out
         (Subst (TmpCtx)
                (SubTuple (Arg new-arg-ty (TmpCtx)) 0 inputs-len) pred_out))
       (let new-x (Get (Arg new-arg-ty (TmpCtx)) inputs-len))
       (let new-body
         (Concat new-pred-out
                 (Single (Bop (Add) new-x
                              (Const (Int (* c k)) new-arg-ty (TmpCtx))))))
       ;; add another value to the loop like i but multiplied
       (let new-loop
         (DoWhile new-inputs
                  new-body))
       ;; union context
       (union (TmpCtx) (InLoop new-inputs new-body))
       ;; old loop equal to new loop
       (union (SubTuple new-loop 0 inputs-len) loop)
       ;; multiplication is equal to the new value
       (union res (Get new-loop inputs-len))
       (delete (TmpCtx)))
    :ruleset loop-multiply-motion)


(relation IfGreaterThanThenOne (i64 i64 i64))

(rule ((DoWhile inputs pred_out)
       (= argx (Get (Arg ty ctx) x))
       (= argy (Get (Arg ty ctx) y))
       ;; iter variable x
       (= (Get pred_out (+ x 1))
          (Bop (Add) argx (Const (Int xconst) ty ctx)))
       ;; iter variable y
       (= (Get pred_out (+ y 1))
          (Bop (Add) argy (Const (Int yconst) ty ctx)))
       (> x y))
      ((IfGreaterThanThenOne x y 1))
      :ruleset always-run)


(rule ((DoWhile inputs pred_out)
       (= argx (Get (Arg ty ctx) x))
       (= argy (Get (Arg ty ctx) y))
       ;; iter variable x
       (= (Get pred_out (+ x 1))
          (Bop (Add) argx (Const (Int xconst) ty ctx)))
       ;; iter variable y
       (= (Get pred_out (+ y 1))
          (Bop (Add) argy (Const (Int yconst) ty ctx)))
       (< x y))
      ((IfGreaterThanThenOne x y 0))
      :ruleset always-run)




;; try to consolidate loop iter variables by finding
;; equivalence between predicates
;; by finding the one that is used by the predicate and changing it to use the other
(rule ((= loop (DoWhile inputs pred_out))
       (HasArgType inputs ty-outer)
       (ContextOf inputs ctx-outer)

       (= argx (Get (Arg ty ctx) x))
       (= argy (Get (Arg ty ctx) y))
       (!= x y)
       (= inputs-len (tuple-length inputs))
       ;; iter variable x
       (= (Get pred_out (+ x 1))
          (Bop (Add) argx (Const (Int xconst) ty ctx)))
       ;; iter variable y
       (= (Get pred_out (+ y 1))
          (Bop (Add) argy (Const (Int yconst) ty ctx)))
       ;; loop condition is over y
       (= (Get pred_out 0)
          (Bop (LessThan) (Get pred_out (+ y 1))
                          (Const (Int n) ty ctx)))
       ;; x starts at a constant zero
       (= (Get inputs x) (Const (Int 0) ty-outer ctx-outer))
       ;; y starts at a constant
       (= (Get inputs y) (Const (Int 0) ty-outer ctx-outer))
       ;; isgreater is 1 when x comes after y
       (IfGreaterThanThenOne x y isgreater)
       ;; x increment is divisible by y increment
       (= factor (/ xconst yconst))
       (= (* factor yconst) xconst)

       ;; we won't run into overflow issues
       (< (+ factor n) 10000)
       (= ty (TupleT ty_list)))
     (;; find another way to express predicate in old loop
      (let old-x-predicate
        (Bop (LessThan) (Get pred_out (+ x 1))
                        (Const (Int (* factor n)) ty ctx)))
      (union (Get pred_out 0) old-x-predicate)

      ;; new inputs with y removed
      (let new-inputs (TupleRemoveAt inputs y))
      ;; new type
      (let new-arg-ty (TupleT (TypeListRemoveAt ty_list y)))
      ;; new body with y removed
      (let new-body
        (DropAt (TmpCtx) y (TupleRemoveAt pred_out (+ y 1))))
      ;; new loop
      (let new-loop
        (DoWhile new-inputs
                 new-body))
      ;; union context
      (union (TmpCtx) (InLoop new-inputs new-body))
      ;; old loop up to y is equal to new loop
      (union (SubTuple loop 0 y) (SubTuple new-loop 0 y))
      ;; old loop from after y to end is equal to new loop
      (union (SubTuple loop (+ y 1) (- inputs-len (+ y 1)))
             (SubTuple new-loop y (- inputs-len (+ y 1))))
      ;; y is equal to x divided by factor
      ;; new x location is x-isgreater
      (union (Get loop y)
             (Bop (Div) (Get new-loop (- x isgreater))
                  (Const (Int factor) ty-outer ctx-outer)))

      (delete (TmpCtx)))
    :ruleset loop-multiply-motion)

;; use these rules to clean up the database, removing helpers
;; this makes the visualization easier to read

(ruleset debug-deletes)

(rule ((HasType a b))
      ((delete (HasType a b)))
      :ruleset debug-deletes)

(rule ((BodyContainsExpr a b))
      ((delete (BodyContainsExpr a b)))
      :ruleset debug-deletes)

(rule ((ExprIsPure e))
      ((delete (ExprIsPure e)))
      :ruleset debug-deletes)

(rule ((HasArgType e ty))
      ((delete (HasArgType e ty)))
      :ruleset debug-deletes)

(rule ((is-inv-Expr e ty))
      ((delete (is-inv-Expr e ty)))
      :ruleset debug-deletes)

(rule ((tuple-length e))
      ((delete (tuple-length e)))
      :ruleset debug-deletes)

(rule ((BinaryOpIsPure e))
      ((delete (BinaryOpIsPure e)))
      :ruleset debug-deletes)

(rule ((TypeList-suffix e a))
      ((delete (TypeList-suffix e a)))
      :ruleset debug-deletes)

(rule ((ContextOf e a))
      ((delete (ContextOf e a)))
      :ruleset debug-deletes)

(rule ((ExprIsResolved e))
      ((delete (ExprIsResolved e)))
      :ruleset debug-deletes)

(rule ((bop->string a b))
      ((delete (bop->string a b)))
      :ruleset debug-deletes)

(rule ((bpred-of-type a b))
      ((delete (bpred-of-type a b)))
      :ruleset debug-deletes)

(rule ((PureType e))
      ((delete (PureType e)))
      :ruleset debug-deletes)

(rule ((PointsToCells a b))
      ((delete (PointsToCells a b)))
      :ruleset debug-deletes)

(rule ((TuplePointsTo e))
      ((delete (TuplePointsTo e)))
      :ruleset debug-deletes)

(rule ((Resolved-List<PtrPointees> e))
      ((delete (Resolved-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((TypeListToList<PtrPointees> e))
      ((delete (TypeListToList<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<PtrPointees> a b))
      ((delete (Cons-List<PtrPointees> a b)))
      :ruleset debug-deletes)

(rule ((Nil-List<PtrPointees>))
      ((delete (Nil-List<PtrPointees>)))
      :ruleset debug-deletes)

(rule ((Length-List<PtrPointees> e))
      ((delete (Length-List<PtrPointees> e)))
      :ruleset debug-deletes)

(rule ((At-List<PtrPointees> a b c))
      ((delete (At-List<PtrPointees> a b c)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<PtrPointees> a))
      ((delete (IsNonEmpty-List<PtrPointees> a)))
      :ruleset debug-deletes)

(rule ((Resolved-List<i64+IntInterval> e))
      ((delete (Resolved-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((Cons-List<i64+IntInterval> a b c))
      ((delete (Cons-List<i64+IntInterval> a b c)))
      :ruleset debug-deletes)

(rule ((Nil-List<i64+IntInterval>))
      ((delete (Nil-List<i64+IntInterval>)))
      :ruleset debug-deletes)

(rule ((Length-List<i64+IntInterval> e))
      ((delete (Length-List<i64+IntInterval> e)))
      :ruleset debug-deletes)

(rule ((At-List<i64+IntInterval> a b c d))
      ((delete (At-List<i64+IntInterval> a b c d)))
      :ruleset debug-deletes)

(rule ((IsNonEmpty-List<i64+IntInterval> a))
      ((delete (IsNonEmpty-List<i64+IntInterval> a)))
      :ruleset debug-deletes)

(rule ((TypeList-ith a b))
      ((delete (TypeList-ith a b)))
      :ruleset debug-deletes)


(unstable-combined-ruleset saturating
    always-run
passthrough
canon
type-analysis
context
interval-analysis
memory-helpers
always-switch-rewrite
loop-iters-analysis
)

(unstable-combined-ruleset cheap-optimizations
    loop-simplify
memory
peepholes
)

(unstable-combined-ruleset all-optimizations
    loop-unroll
switch_rewrite
loop-inv-motion
loop-strength-reduction
loop-peel
loop-inversion
loop-multiply-motion
loop-simplify
memory
peepholes
)


;; A Perm is a reverse list of integers
(datatype Perm (PermPush i64 Perm) (PNil))
;; expr1 is a list of expressions of the form (Get expr2 i),
;; where all the i's form a permutation
(relation IVTPermutationAnalysisDemand (Expr))
;;                                    expr1 curr  expr2
(relation IVTPermutationAnalysisImpl (Expr  Expr  Expr Perm))
;;                                expr1 expr2
(relation IVTPermutationAnalysis (Expr Expr Perm))

(rule (
    (DoWhile inpW outW)
) (
    (IVTPermutationAnalysisDemand outW)
) :ruleset always-run)

(rule (
    (IVTPermutationAnalysisDemand loop-body)
    (= loop-body (Concat (Single (Get expr ith)) rest))
) (
    (let perm (PermPush ith (PNil)))
    (IVTPermutationAnalysisImpl loop-body rest expr perm)
) :ruleset always-run)

(rule (
    (IVTPermutationAnalysisImpl loop-body curr expr perm)
    (= curr (Concat (Single (Get expr ith)) rest))
) (
    (let new-perm (PermPush ith perm))
    (IVTPermutationAnalysisImpl loop-body rest expr new-perm)
) :ruleset always-run)

(rule (
    (IVTPermutationAnalysisImpl loop-body (Single last) expr perm)
    (= last (Get expr ith))
) (
    (let new-perm (PermPush ith perm))
    (IVTPermutationAnalysis loop-body expr new-perm)
) :ruleset always-run)

(function ApplyPerm (Perm Expr) Expr)

(rewrite (ApplyPerm (PermPush ith rest) expr)
         (Concat (ApplyPerm rest expr) (Single (Get expr ith)))
    :when ((= rest (PermPush _jth _rest)))
    :ruleset always-run)
(rewrite (ApplyPerm (PermPush ith (PNil)) expr) (Single (Get expr ith))
    :ruleset always-run)

(ruleset loop-inversion)

;; This is for unified handling of thn/els branches
(relation ith-arg-is-bool (Expr Expr Expr i64 Expr Expr))

(rule (
    (= loop (DoWhile inpW outW))
    (IVTPermutationAnalysis outW conditional perm)
    (= conditional (If condI inpI thn els))

    (= (Get thn ith) (Const (Bool true) _unused1 _unused2))
    (= (Get els ith) (Const (Bool false) _unused3 _unused4))
) (
    (ith-arg-is-bool conditional condI inpI ith thn els)
) :ruleset always-run)

(rule (
    (= loop (DoWhile inpW outW))
    (IVTPermutationAnalysis outW conditional perm)
    (= conditional (If condI inpI thn els))

    (= (Get thn ith) (Const (Bool false) _unused1 _unused2))
    (= (Get els ith) (Const (Bool true) _unused3 _unused4))
) (
    ;; TODO: this may introduce overhead, but is the only way to
    ;; not have two rules
    (ith-arg-is-bool conditional (Uop (Not) condI) inpI ith els thn)
) :ruleset always-run)

(rule (
    (= loop (DoWhile inpW outW))
    (IVTPermutationAnalysis outW conditional perm)
    ;; This generalizes the following conditions:
    ;;   (= conditional (If condI inpI thn els))
    ;;   (= (Get thn ith) (Const (Bool true) _unused1 _unused2))
    ;;   (= (Get els ith) (Const (Bool false) _unused3 _unused4))
    (ith-arg-is-bool conditional condI inpI ith thn els)

    (ContextOf inpW outer-ctx)
    (ContextOf inpI if-ctx)
    (HasType inpI argI)
) (
    ;; first peeled condition
    (let new-if-cond (Subst outer-ctx inpW condI))
    ;; if contexts
    (let new-if-inp (Subst outer-ctx inpW inpI))
    (let new-if-true-ctx (InIf true new-if-cond new-if-inp))
    (let new-if-false-ctx (InIf false new-if-cond new-if-inp))

    (let new-loop-context (TmpCtx))

    ;; body
    (let new-loop-outputs_
        (TupleRemoveAt (ApplyPerm perm thn) 0))
    (let new-loop-outputs
        (Subst new-loop-context new-loop-outputs_
            (Concat (Single condI) inpI)))

    (let new-loop (DoWhile (Arg argI new-if-true-ctx) new-loop-outputs))
    (let new-if
        (If new-if-cond new-if-inp
            new-loop
            (Arg argI new-if-false-ctx)))

    ;; Apply the body of the false branch as an afterprocessing wrapper
    (let new-expr_
        (Subst outer-ctx new-if els))
    (let new-expr
        (TupleRemoveAt
            (ApplyPerm perm new-expr_)
            0))

    (union new-expr loop)
    (union new-loop-context (InLoop (Arg argI new-if-true-ctx) new-loop-outputs))

    (delete (DoWhile inpW outW))
    (delete (TmpCtx))
) :ruleset loop-inversion)


; Program nodes
(let __tmp0 (IntT ))
(let __tmp1 (StateT ))
(let __tmp2 (TNil ))
(let __tmp3 (TCons __tmp1 __tmp2))
(let __tmp4 (TCons __tmp0 __tmp3))
(let __tmp5 (TCons __tmp0 __tmp4))
(let __tmp6 (TupleT __tmp5))
(let __tmp7 (InFunc "main"))
(let __tmp8 (Arg __tmp6 __tmp7))
(let __tmp9 (Get __tmp8 0))
(let __tmp10 (Single __tmp9))
(let __tmp11 (Get __tmp8 1))
(let __tmp12 (Single __tmp11))
(let __tmp13 (Get __tmp8 2))
(let __tmp14 (Single __tmp13))
(let __tmp15 (Concat __tmp12 __tmp14))
(let __tmp16 (Concat __tmp10 __tmp15))
(let __tmp17 (Call "ack" __tmp16))
(let __tmp18 (Eq ))
(let __tmp19 (Get __tmp16 0))
(let __tmp20 (Int 0))
(let __tmp21 (Const __tmp20 __tmp6 __tmp7))
(let __tmp22 (Bop __tmp18 __tmp19 __tmp21))
(let __tmp23 (Get __tmp16 2))
(let __tmp24 (Single __tmp23))
(let __tmp25 (Get __tmp16 1))
(let __tmp26 (Single __tmp25))
(let __tmp27 (Int 1))
(let __tmp28 (Const __tmp27 __tmp6 __tmp7))
(let __tmp29 (Single __tmp28))
(let __tmp30 (Single __tmp19))
(let __tmp31 (Single __tmp21))
(let __tmp32 (Concat __tmp30 __tmp31))
(let __tmp33 (Concat __tmp29 __tmp32))
(let __tmp34 (Concat __tmp26 __tmp33))
(let __tmp35 (Concat __tmp24 __tmp34))
(let __tmp36 (TCons __tmp0 __tmp2))
(let __tmp37 (TCons __tmp0 __tmp36))
(let __tmp38 (TCons __tmp0 __tmp37))
(let __tmp39 (TCons __tmp0 __tmp38))
(let __tmp40 (TCons __tmp1 __tmp39))
(let __tmp41 (TupleT __tmp40))
(let __tmp42 (InIf true __tmp22 __tmp35))
(let __tmp43 (Arg __tmp41 __tmp42))
(let __tmp44 (Get __tmp43 0))
(let __tmp45 (Single __tmp44))
(let __tmp46 (Add ))
(let __tmp47 (Get __tmp43 1))
(let __tmp48 (Get __tmp43 2))
(let __tmp49 (Bop __tmp46 __tmp47 __tmp48))
(let __tmp50 (Single __tmp49))
(let __tmp51 (Concat __tmp45 __tmp50))
(let __tmp52 (InIf false __tmp22 __tmp35))
(let __tmp53 (Arg __tmp41 __tmp52))
(let __tmp54 (Get __tmp53 1))
(let __tmp55 (Get __tmp53 4))
(let __tmp56 (Bop __tmp18 __tmp54 __tmp55))
(let __tmp57 (Get __tmp53 0))
(let __tmp58 (Single __tmp57))
(let __tmp59 (Single __tmp54))
(let __tmp60 (Get __tmp53 2))
(let __tmp61 (Single __tmp60))
(let __tmp62 (Get __tmp53 3))
(let __tmp63 (Single __tmp62))
(let __tmp64 (Concat __tmp61 __tmp63))
(let __tmp65 (Concat __tmp59 __tmp64))
(let __tmp66 (Concat __tmp58 __tmp65))
(let __tmp67 (Sub ))
(let __tmp68 (TCons __tmp1 __tmp38))
(let __tmp69 (TupleT __tmp68))
(let __tmp70 (InIf true __tmp56 __tmp66))
(let __tmp71 (Arg __tmp69 __tmp70))
(let __tmp72 (Get __tmp71 3))
(let __tmp73 (Get __tmp71 2))
(let __tmp74 (Bop __tmp67 __tmp72 __tmp73))
(let __tmp75 (Single __tmp74))
(let __tmp76 (Single __tmp73))
(let __tmp77 (Get __tmp71 0))
(let __tmp78 (Single __tmp77))
(let __tmp79 (Concat __tmp76 __tmp78))
(let __tmp80 (Concat __tmp75 __tmp79))
(let __tmp81 (Call "ack" __tmp80))
(let __tmp82 (Get __tmp81 1))
(let __tmp83 (Single __tmp82))
(let __tmp84 (Get __tmp81 0))
(let __tmp85 (Single __tmp84))
(let __tmp86 (Concat __tmp83 __tmp85))
(let __tmp87 (InIf false __tmp56 __tmp66))
(let __tmp88 (Arg __tmp69 __tmp87))
(let __tmp89 (Get __tmp88 3))
(let __tmp90 (Get __tmp88 2))
(let __tmp91 (Bop __tmp67 __tmp89 __tmp90))
(let __tmp92 (Single __tmp91))
(let __tmp93 (Single __tmp89))
(let __tmp94 (Get __tmp88 1))
(let __tmp95 (Bop __tmp67 __tmp94 __tmp90))
(let __tmp96 (Single __tmp95))
(let __tmp97 (Get __tmp88 0))
(let __tmp98 (Single __tmp97))
(let __tmp99 (Concat __tmp96 __tmp98))
(let __tmp100 (Concat __tmp93 __tmp99))
(let __tmp101 (Call "ack" __tmp100))
(let __tmp102 (Get __tmp101 0))
(let __tmp103 (Single __tmp102))
(let __tmp104 (Get __tmp101 1))
(let __tmp105 (Single __tmp104))
(let __tmp106 (Concat __tmp103 __tmp105))
(let __tmp107 (Concat __tmp92 __tmp106))
(let __tmp108 (Call "ack" __tmp107))
(let __tmp109 (Get __tmp108 1))
(let __tmp110 (Single __tmp109))
(let __tmp111 (Get __tmp108 0))
(let __tmp112 (Single __tmp111))
(let __tmp113 (Concat __tmp110 __tmp112))
(let __tmp114 (If __tmp56 __tmp66 __tmp86 __tmp113))
(let __tmp115 (Get __tmp114 0))
(let __tmp116 (Single __tmp115))
(let __tmp117 (Get __tmp114 1))
(let __tmp118 (Single __tmp117))
(let __tmp119 (Concat __tmp116 __tmp118))
(let __tmp120 (If __tmp22 __tmp35 __tmp51 __tmp119))
(let __tmp121 (Get __tmp120 1))
(let __tmp122 (Single __tmp121))
(let __tmp123 (Get __tmp120 0))
(let __tmp124 (Single __tmp123))
(let __tmp125 (Concat __tmp122 __tmp124))
(let __tmp126 (InFunc "ack"))
(let __tmp127 (Arg __tmp6 __tmp126))
(let __tmp128 (Get __tmp127 0))
(let __tmp129 (Const __tmp20 __tmp6 __tmp126))
(let __tmp130 (Bop __tmp18 __tmp128 __tmp129))
(let __tmp131 (Get __tmp127 2))
(let __tmp132 (Single __tmp131))
(let __tmp133 (Get __tmp127 1))
(let __tmp134 (Single __tmp133))
(let __tmp135 (Const __tmp27 __tmp6 __tmp126))
(let __tmp136 (Single __tmp135))
(let __tmp137 (Single __tmp128))
(let __tmp138 (Single __tmp129))
(let __tmp139 (Concat __tmp137 __tmp138))
(let __tmp140 (Concat __tmp136 __tmp139))
(let __tmp141 (Concat __tmp134 __tmp140))
(let __tmp142 (Concat __tmp132 __tmp141))
(let __tmp143 (InIf false __tmp130 __tmp142))
(let __tmp144 (Arg __tmp41 __tmp143))
(let __tmp145 (Get __tmp144 1))
(let __tmp146 (Get __tmp144 4))
(let __tmp147 (Bop __tmp18 __tmp145 __tmp146))
(let __tmp148 (Get __tmp144 0))
(let __tmp149 (Single __tmp148))
(let __tmp150 (Single __tmp145))
(let __tmp151 (Get __tmp144 2))
(let __tmp152 (Single __tmp151))
(let __tmp153 (Get __tmp144 3))
(let __tmp154 (Single __tmp153))
(let __tmp155 (Concat __tmp152 __tmp154))
(let __tmp156 (Concat __tmp150 __tmp155))
(let __tmp157 (Concat __tmp149 __tmp156))
(let __tmp158 (InIf true __tmp147 __tmp157))
(let __tmp159 (Arg __tmp69 __tmp158))
(let __tmp160 (Get __tmp159 3))
(let __tmp161 (Get __tmp159 2))
(let __tmp162 (Bop __tmp67 __tmp160 __tmp161))
(let __tmp163 (Single __tmp162))
(let __tmp164 (Single __tmp161))
(let __tmp165 (Get __tmp159 0))
(let __tmp166 (Single __tmp165))
(let __tmp167 (Concat __tmp164 __tmp166))
(let __tmp168 (Concat __tmp163 __tmp167))
(let __tmp169 (Call "ack" __tmp168))
(let __tmp170 (Get __tmp168 0))
(let __tmp171 (Const __tmp20 __tmp69 __tmp158))
(let __tmp172 (Bop __tmp18 __tmp170 __tmp171))
(let __tmp173 (Get __tmp168 2))
(let __tmp174 (Single __tmp173))
(let __tmp175 (Get __tmp168 1))
(let __tmp176 (Single __tmp175))
(let __tmp177 (Const __tmp27 __tmp69 __tmp158))
(let __tmp178 (Single __tmp177))
(let __tmp179 (Single __tmp170))
(let __tmp180 (Single __tmp171))
(let __tmp181 (Concat __tmp179 __tmp180))
(let __tmp182 (Concat __tmp178 __tmp181))
(let __tmp183 (Concat __tmp176 __tmp182))
(let __tmp184 (Concat __tmp174 __tmp183))
(let __tmp185 (InIf true __tmp172 __tmp184))
(let __tmp186 (Arg __tmp41 __tmp185))
(let __tmp187 (Get __tmp186 0))
(let __tmp188 (Single __tmp187))
(let __tmp189 (Get __tmp186 1))
(let __tmp190 (Get __tmp186 2))
(let __tmp191 (Bop __tmp46 __tmp189 __tmp190))
(let __tmp192 (Single __tmp191))
(let __tmp193 (Concat __tmp188 __tmp192))
(let __tmp194 (InIf false __tmp172 __tmp184))
(let __tmp195 (Arg __tmp41 __tmp194))
(let __tmp196 (Get __tmp195 1))
(let __tmp197 (Get __tmp195 4))
(let __tmp198 (Bop __tmp18 __tmp196 __tmp197))
(let __tmp199 (Get __tmp195 0))
(let __tmp200 (Single __tmp199))
(let __tmp201 (Single __tmp196))
(let __tmp202 (Get __tmp195 2))
(let __tmp203 (Single __tmp202))
(let __tmp204 (Get __tmp195 3))
(let __tmp205 (Single __tmp204))
(let __tmp206 (Concat __tmp203 __tmp205))
(let __tmp207 (Concat __tmp201 __tmp206))
(let __tmp208 (Concat __tmp200 __tmp207))
(let __tmp209 (InIf true __tmp198 __tmp208))
(let __tmp210 (Arg __tmp69 __tmp209))
(let __tmp211 (Get __tmp210 3))
(let __tmp212 (Get __tmp210 2))
(let __tmp213 (Bop __tmp67 __tmp211 __tmp212))
(let __tmp214 (Single __tmp213))
(let __tmp215 (Single __tmp212))
(let __tmp216 (Get __tmp210 0))
(let __tmp217 (Single __tmp216))
(let __tmp218 (Concat __tmp215 __tmp217))
(let __tmp219 (Concat __tmp214 __tmp218))
(let __tmp220 (Call "ack" __tmp219))
(let __tmp221 (Get __tmp220 1))
(let __tmp222 (Single __tmp221))
(let __tmp223 (Get __tmp220 0))
(let __tmp224 (Single __tmp223))
(let __tmp225 (Concat __tmp222 __tmp224))
(let __tmp226 (InIf false __tmp198 __tmp208))
(let __tmp227 (Arg __tmp69 __tmp226))
(let __tmp228 (Get __tmp227 3))
(let __tmp229 (Get __tmp227 2))
(let __tmp230 (Bop __tmp67 __tmp228 __tmp229))
(let __tmp231 (Single __tmp230))
(let __tmp232 (Single __tmp228))
(let __tmp233 (Get __tmp227 1))
(let __tmp234 (Bop __tmp67 __tmp233 __tmp229))
(let __tmp235 (Single __tmp234))
(let __tmp236 (Get __tmp227 0))
(let __tmp237 (Single __tmp236))
(let __tmp238 (Concat __tmp235 __tmp237))
(let __tmp239 (Concat __tmp232 __tmp238))
(let __tmp240 (Call "ack" __tmp239))
(let __tmp241 (Get __tmp240 0))
(let __tmp242 (Single __tmp241))
(let __tmp243 (Get __tmp240 1))
(let __tmp244 (Single __tmp243))
(let __tmp245 (Concat __tmp242 __tmp244))
(let __tmp246 (Concat __tmp231 __tmp245))
(let __tmp247 (Call "ack" __tmp246))
(let __tmp248 (Get __tmp247 1))
(let __tmp249 (Single __tmp248))
(let __tmp250 (Get __tmp247 0))
(let __tmp251 (Single __tmp250))
(let __tmp252 (Concat __tmp249 __tmp251))
(let __tmp253 (If __tmp198 __tmp208 __tmp225 __tmp252))
(let __tmp254 (Get __tmp253 0))
(let __tmp255 (Single __tmp254))
(let __tmp256 (Get __tmp253 1))
(let __tmp257 (Single __tmp256))
(let __tmp258 (Concat __tmp255 __tmp257))
(let __tmp259 (If __tmp172 __tmp184 __tmp193 __tmp258))
(let __tmp260 (Get __tmp259 1))
(let __tmp261 (Single __tmp260))
(let __tmp262 (Get __tmp259 0))
(let __tmp263 (Single __tmp262))
(let __tmp264 (Concat __tmp261 __tmp263))
(let __tmp265 (InIf false __tmp147 __tmp157))
(let __tmp266 (Arg __tmp69 __tmp265))
(let __tmp267 (Get __tmp266 3))
(let __tmp268 (Single __tmp267))
(let __tmp269 (Get __tmp266 1))
(let __tmp270 (Get __tmp266 2))
(let __tmp271 (Bop __tmp67 __tmp269 __tmp270))
(let __tmp272 (Single __tmp271))
(let __tmp273 (Get __tmp266 0))
(let __tmp274 (Single __tmp273))
(let __tmp275 (Concat __tmp272 __tmp274))
(let __tmp276 (Concat __tmp268 __tmp275))
(let __tmp277 (Call "ack" __tmp276))
(let __tmp278 (Get __tmp276 0))
(let __tmp279 (Const __tmp20 __tmp69 __tmp265))
(let __tmp280 (Bop __tmp18 __tmp278 __tmp279))
(let __tmp281 (Get __tmp276 2))
(let __tmp282 (Single __tmp281))
(let __tmp283 (Get __tmp276 1))
(let __tmp284 (Single __tmp283))
(let __tmp285 (Const __tmp27 __tmp69 __tmp265))
(let __tmp286 (Single __tmp285))
(let __tmp287 (Single __tmp278))
(let __tmp288 (Single __tmp279))
(let __tmp289 (Concat __tmp287 __tmp288))
(let __tmp290 (Concat __tmp286 __tmp289))
(let __tmp291 (Concat __tmp284 __tmp290))
(let __tmp292 (Concat __tmp282 __tmp291))
(let __tmp293 (InIf true __tmp280 __tmp292))
(let __tmp294 (Arg __tmp41 __tmp293))
(let __tmp295 (Get __tmp294 0))
(let __tmp296 (Single __tmp295))
(let __tmp297 (Get __tmp294 1))
(let __tmp298 (Get __tmp294 2))
(let __tmp299 (Bop __tmp46 __tmp297 __tmp298))
(let __tmp300 (Single __tmp299))
(let __tmp301 (Concat __tmp296 __tmp300))
(let __tmp302 (InIf false __tmp280 __tmp292))
(let __tmp303 (Arg __tmp41 __tmp302))
(let __tmp304 (Get __tmp303 1))
(let __tmp305 (Get __tmp303 4))
(let __tmp306 (Bop __tmp18 __tmp304 __tmp305))
(let __tmp307 (Get __tmp303 0))
(let __tmp308 (Single __tmp307))
(let __tmp309 (Single __tmp304))
(let __tmp310 (Get __tmp303 2))
(let __tmp311 (Single __tmp310))
(let __tmp312 (Get __tmp303 3))
(let __tmp313 (Single __tmp312))
(let __tmp314 (Concat __tmp311 __tmp313))
(let __tmp315 (Concat __tmp309 __tmp314))
(let __tmp316 (Concat __tmp308 __tmp315))
(let __tmp317 (InIf true __tmp306 __tmp316))
(let __tmp318 (Arg __tmp69 __tmp317))
(let __tmp319 (Get __tmp318 3))
(let __tmp320 (Get __tmp318 2))
(let __tmp321 (Bop __tmp67 __tmp319 __tmp320))
(let __tmp322 (Single __tmp321))
(let __tmp323 (Single __tmp320))
(let __tmp324 (Get __tmp318 0))
(let __tmp325 (Single __tmp324))
(let __tmp326 (Concat __tmp323 __tmp325))
(let __tmp327 (Concat __tmp322 __tmp326))
(let __tmp328 (Call "ack" __tmp327))
(let __tmp329 (Get __tmp328 1))
(let __tmp330 (Single __tmp329))
(let __tmp331 (Get __tmp328 0))
(let __tmp332 (Single __tmp331))
(let __tmp333 (Concat __tmp330 __tmp332))
(let __tmp334 (InIf false __tmp306 __tmp316))
(let __tmp335 (Arg __tmp69 __tmp334))
(let __tmp336 (Get __tmp335 3))
(let __tmp337 (Get __tmp335 2))
(let __tmp338 (Bop __tmp67 __tmp336 __tmp337))
(let __tmp339 (Single __tmp338))
(let __tmp340 (Single __tmp336))
(let __tmp341 (Get __tmp335 1))
(let __tmp342 (Bop __tmp67 __tmp341 __tmp337))
(let __tmp343 (Single __tmp342))
(let __tmp344 (Get __tmp335 0))
(let __tmp345 (Single __tmp344))
(let __tmp346 (Concat __tmp343 __tmp345))
(let __tmp347 (Concat __tmp340 __tmp346))
(let __tmp348 (Call "ack" __tmp347))
(let __tmp349 (Get __tmp348 0))
(let __tmp350 (Single __tmp349))
(let __tmp351 (Get __tmp348 1))
(let __tmp352 (Single __tmp351))
(let __tmp353 (Concat __tmp350 __tmp352))
(let __tmp354 (Concat __tmp339 __tmp353))
(let __tmp355 (Call "ack" __tmp354))
(let __tmp356 (Get __tmp355 1))
(let __tmp357 (Single __tmp356))
(let __tmp358 (Get __tmp355 0))
(let __tmp359 (Single __tmp358))
(let __tmp360 (Concat __tmp357 __tmp359))
(let __tmp361 (If __tmp306 __tmp316 __tmp333 __tmp360))
(let __tmp362 (Get __tmp361 0))
(let __tmp363 (Single __tmp362))
(let __tmp364 (Get __tmp361 1))
(let __tmp365 (Single __tmp364))
(let __tmp366 (Concat __tmp363 __tmp365))
(let __tmp367 (If __tmp280 __tmp292 __tmp301 __tmp366))
(let __tmp368 (Get __tmp367 1))
(let __tmp369 (Single __tmp368))
(let __tmp370 (Get __tmp367 0))
(let __tmp371 (Single __tmp370))
(let __tmp372 (Concat __tmp369 __tmp371))
(let __tmp373 (Bop __tmp67 __tmp267 __tmp270))
(let __tmp374 (Single __tmp373))
(let __tmp375 (Get __tmp277 0))
(let __tmp376 (Single __tmp375))
(let __tmp377 (Get __tmp277 1))
(let __tmp378 (Single __tmp377))
(let __tmp379 (Concat __tmp376 __tmp378))
(let __tmp380 (Concat __tmp374 __tmp379))
(let __tmp381 (Call "ack" __tmp380))
(let __tmp382 (Get __tmp380 0))
(let __tmp383 (Bop __tmp18 __tmp382 __tmp279))
(let __tmp384 (Get __tmp380 2))
(let __tmp385 (Single __tmp384))
(let __tmp386 (Get __tmp380 1))
(let __tmp387 (Single __tmp386))
(let __tmp388 (Single __tmp382))
(let __tmp389 (Concat __tmp388 __tmp288))
(let __tmp390 (Concat __tmp286 __tmp389))
(let __tmp391 (Concat __tmp387 __tmp390))
(let __tmp392 (Concat __tmp385 __tmp391))
(let __tmp393 (InIf true __tmp383 __tmp392))
(let __tmp394 (Arg __tmp41 __tmp393))
(let __tmp395 (Get __tmp394 0))
(let __tmp396 (Single __tmp395))
(let __tmp397 (Get __tmp394 1))
(let __tmp398 (Get __tmp394 2))
(let __tmp399 (Bop __tmp46 __tmp397 __tmp398))
(let __tmp400 (Single __tmp399))
(let __tmp401 (Concat __tmp396 __tmp400))
(let __tmp402 (InIf false __tmp383 __tmp392))
(let __tmp403 (Arg __tmp41 __tmp402))
(let __tmp404 (Get __tmp403 1))
(let __tmp405 (Get __tmp403 4))
(let __tmp406 (Bop __tmp18 __tmp404 __tmp405))
(let __tmp407 (Get __tmp403 0))
(let __tmp408 (Single __tmp407))
(let __tmp409 (Single __tmp404))
(let __tmp410 (Get __tmp403 2))
(let __tmp411 (Single __tmp410))
(let __tmp412 (Get __tmp403 3))
(let __tmp413 (Single __tmp412))
(let __tmp414 (Concat __tmp411 __tmp413))
(let __tmp415 (Concat __tmp409 __tmp414))
(let __tmp416 (Concat __tmp408 __tmp415))
(let __tmp417 (InIf true __tmp406 __tmp416))
(let __tmp418 (Arg __tmp69 __tmp417))
(let __tmp419 (Get __tmp418 3))
(let __tmp420 (Get __tmp418 2))
(let __tmp421 (Bop __tmp67 __tmp419 __tmp420))
(let __tmp422 (Single __tmp421))
(let __tmp423 (Single __tmp420))
(let __tmp424 (Get __tmp418 0))
(let __tmp425 (Single __tmp424))
(let __tmp426 (Concat __tmp423 __tmp425))
(let __tmp427 (Concat __tmp422 __tmp426))
(let __tmp428 (Call "ack" __tmp427))
(let __tmp429 (Get __tmp428 1))
(let __tmp430 (Single __tmp429))
(let __tmp431 (Get __tmp428 0))
(let __tmp432 (Single __tmp431))
(let __tmp433 (Concat __tmp430 __tmp432))
(let __tmp434 (InIf false __tmp406 __tmp416))
(let __tmp435 (Arg __tmp69 __tmp434))
(let __tmp436 (Get __tmp435 3))
(let __tmp437 (Get __tmp435 2))
(let __tmp438 (Bop __tmp67 __tmp436 __tmp437))
(let __tmp439 (Single __tmp438))
(let __tmp440 (Single __tmp436))
(let __tmp441 (Get __tmp435 1))
(let __tmp442 (Bop __tmp67 __tmp441 __tmp437))
(let __tmp443 (Single __tmp442))
(let __tmp444 (Get __tmp435 0))
(let __tmp445 (Single __tmp444))
(let __tmp446 (Concat __tmp443 __tmp445))
(let __tmp447 (Concat __tmp440 __tmp446))
(let __tmp448 (Call "ack" __tmp447))
(let __tmp449 (Get __tmp448 0))
(let __tmp450 (Single __tmp449))
(let __tmp451 (Get __tmp448 1))
(let __tmp452 (Single __tmp451))
(let __tmp453 (Concat __tmp450 __tmp452))
(let __tmp454 (Concat __tmp439 __tmp453))
(let __tmp455 (Call "ack" __tmp454))
(let __tmp456 (Get __tmp455 1))
(let __tmp457 (Single __tmp456))
(let __tmp458 (Get __tmp455 0))
(let __tmp459 (Single __tmp458))
(let __tmp460 (Concat __tmp457 __tmp459))
(let __tmp461 (If __tmp406 __tmp416 __tmp433 __tmp460))
(let __tmp462 (Get __tmp461 0))
(let __tmp463 (Single __tmp462))
(let __tmp464 (Get __tmp461 1))
(let __tmp465 (Single __tmp464))
(let __tmp466 (Concat __tmp463 __tmp465))
(let __tmp467 (If __tmp383 __tmp392 __tmp401 __tmp466))
(let __tmp468 (Get __tmp467 1))
(let __tmp469 (Single __tmp468))
(let __tmp470 (Get __tmp467 0))
(let __tmp471 (Single __tmp470))
(let __tmp472 (Concat __tmp469 __tmp471))
(let __tmp473 (Get __tmp80 0))
(let __tmp474 (Const __tmp20 __tmp69 __tmp70))
(let __tmp475 (Bop __tmp18 __tmp473 __tmp474))
(let __tmp476 (Get __tmp80 2))
(let __tmp477 (Single __tmp476))
(let __tmp478 (Get __tmp80 1))
(let __tmp479 (Single __tmp478))
(let __tmp480 (Const __tmp27 __tmp69 __tmp70))
(let __tmp481 (Single __tmp480))
(let __tmp482 (Single __tmp473))
(let __tmp483 (Single __tmp474))
(let __tmp484 (Concat __tmp482 __tmp483))
(let __tmp485 (Concat __tmp481 __tmp484))
(let __tmp486 (Concat __tmp479 __tmp485))
(let __tmp487 (Concat __tmp477 __tmp486))
(let __tmp488 (InIf true __tmp475 __tmp487))
(let __tmp489 (Arg __tmp41 __tmp488))
(let __tmp490 (Get __tmp489 0))
(let __tmp491 (Single __tmp490))
(let __tmp492 (Get __tmp489 1))
(let __tmp493 (Get __tmp489 2))
(let __tmp494 (Bop __tmp46 __tmp492 __tmp493))
(let __tmp495 (Single __tmp494))
(let __tmp496 (Concat __tmp491 __tmp495))
(let __tmp497 (InIf false __tmp475 __tmp487))
(let __tmp498 (Arg __tmp41 __tmp497))
(let __tmp499 (Get __tmp498 1))
(let __tmp500 (Get __tmp498 4))
(let __tmp501 (Bop __tmp18 __tmp499 __tmp500))
(let __tmp502 (Get __tmp498 0))
(let __tmp503 (Single __tmp502))
(let __tmp504 (Single __tmp499))
(let __tmp505 (Get __tmp498 2))
(let __tmp506 (Single __tmp505))
(let __tmp507 (Get __tmp498 3))
(let __tmp508 (Single __tmp507))
(let __tmp509 (Concat __tmp506 __tmp508))
(let __tmp510 (Concat __tmp504 __tmp509))
(let __tmp511 (Concat __tmp503 __tmp510))
(let __tmp512 (InIf true __tmp501 __tmp511))
(let __tmp513 (Arg __tmp69 __tmp512))
(let __tmp514 (Get __tmp513 3))
(let __tmp515 (Get __tmp513 2))
(let __tmp516 (Bop __tmp67 __tmp514 __tmp515))
(let __tmp517 (Single __tmp516))
(let __tmp518 (Single __tmp515))
(let __tmp519 (Get __tmp513 0))
(let __tmp520 (Single __tmp519))
(let __tmp521 (Concat __tmp518 __tmp520))
(let __tmp522 (Concat __tmp517 __tmp521))
(let __tmp523 (Call "ack" __tmp522))
(let __tmp524 (Get __tmp523 1))
(let __tmp525 (Single __tmp524))
(let __tmp526 (Get __tmp523 0))
(let __tmp527 (Single __tmp526))
(let __tmp528 (Concat __tmp525 __tmp527))
(let __tmp529 (InIf false __tmp501 __tmp511))
(let __tmp530 (Arg __tmp69 __tmp529))
(let __tmp531 (Get __tmp530 3))
(let __tmp532 (Get __tmp530 2))
(let __tmp533 (Bop __tmp67 __tmp531 __tmp532))
(let __tmp534 (Single __tmp533))
(let __tmp535 (Single __tmp531))
(let __tmp536 (Get __tmp530 1))
(let __tmp537 (Bop __tmp67 __tmp536 __tmp532))
(let __tmp538 (Single __tmp537))
(let __tmp539 (Get __tmp530 0))
(let __tmp540 (Single __tmp539))
(let __tmp541 (Concat __tmp538 __tmp540))
(let __tmp542 (Concat __tmp535 __tmp541))
(let __tmp543 (Call "ack" __tmp542))
(let __tmp544 (Get __tmp543 0))
(let __tmp545 (Single __tmp544))
(let __tmp546 (Get __tmp543 1))
(let __tmp547 (Single __tmp546))
(let __tmp548 (Concat __tmp545 __tmp547))
(let __tmp549 (Concat __tmp534 __tmp548))
(let __tmp550 (Call "ack" __tmp549))
(let __tmp551 (Get __tmp550 1))
(let __tmp552 (Single __tmp551))
(let __tmp553 (Get __tmp550 0))
(let __tmp554 (Single __tmp553))
(let __tmp555 (Concat __tmp552 __tmp554))
(let __tmp556 (If __tmp501 __tmp511 __tmp528 __tmp555))
(let __tmp557 (Get __tmp556 0))
(let __tmp558 (Single __tmp557))
(let __tmp559 (Get __tmp556 1))
(let __tmp560 (Single __tmp559))
(let __tmp561 (Concat __tmp558 __tmp560))
(let __tmp562 (If __tmp475 __tmp487 __tmp496 __tmp561))
(let __tmp563 (Get __tmp562 1))
(let __tmp564 (Single __tmp563))
(let __tmp565 (Get __tmp562 0))
(let __tmp566 (Single __tmp565))
(let __tmp567 (Concat __tmp564 __tmp566))
(let __tmp568 (Get __tmp100 0))
(let __tmp569 (Const __tmp20 __tmp69 __tmp87))
(let __tmp570 (Bop __tmp18 __tmp568 __tmp569))
(let __tmp571 (Get __tmp100 2))
(let __tmp572 (Single __tmp571))
(let __tmp573 (Get __tmp100 1))
(let __tmp574 (Single __tmp573))
(let __tmp575 (Const __tmp27 __tmp69 __tmp87))
(let __tmp576 (Single __tmp575))
(let __tmp577 (Single __tmp568))
(let __tmp578 (Single __tmp569))
(let __tmp579 (Concat __tmp577 __tmp578))
(let __tmp580 (Concat __tmp576 __tmp579))
(let __tmp581 (Concat __tmp574 __tmp580))
(let __tmp582 (Concat __tmp572 __tmp581))
(let __tmp583 (InIf true __tmp570 __tmp582))
(let __tmp584 (Arg __tmp41 __tmp583))
(let __tmp585 (Get __tmp584 0))
(let __tmp586 (Single __tmp585))
(let __tmp587 (Get __tmp584 1))
(let __tmp588 (Get __tmp584 2))
(let __tmp589 (Bop __tmp46 __tmp587 __tmp588))
(let __tmp590 (Single __tmp589))
(let __tmp591 (Concat __tmp586 __tmp590))
(let __tmp592 (InIf false __tmp570 __tmp582))
(let __tmp593 (Arg __tmp41 __tmp592))
(let __tmp594 (Get __tmp593 1))
(let __tmp595 (Get __tmp593 4))
(let __tmp596 (Bop __tmp18 __tmp594 __tmp595))
(let __tmp597 (Get __tmp593 0))
(let __tmp598 (Single __tmp597))
(let __tmp599 (Single __tmp594))
(let __tmp600 (Get __tmp593 2))
(let __tmp601 (Single __tmp600))
(let __tmp602 (Get __tmp593 3))
(let __tmp603 (Single __tmp602))
(let __tmp604 (Concat __tmp601 __tmp603))
(let __tmp605 (Concat __tmp599 __tmp604))
(let __tmp606 (Concat __tmp598 __tmp605))
(let __tmp607 (InIf true __tmp596 __tmp606))
(let __tmp608 (Arg __tmp69 __tmp607))
(let __tmp609 (Get __tmp608 3))
(let __tmp610 (Get __tmp608 2))
(let __tmp611 (Bop __tmp67 __tmp609 __tmp610))
(let __tmp612 (Single __tmp611))
(let __tmp613 (Single __tmp610))
(let __tmp614 (Get __tmp608 0))
(let __tmp615 (Single __tmp614))
(let __tmp616 (Concat __tmp613 __tmp615))
(let __tmp617 (Concat __tmp612 __tmp616))
(let __tmp618 (Call "ack" __tmp617))
(let __tmp619 (Get __tmp618 1))
(let __tmp620 (Single __tmp619))
(let __tmp621 (Get __tmp618 0))
(let __tmp622 (Single __tmp621))
(let __tmp623 (Concat __tmp620 __tmp622))
(let __tmp624 (InIf false __tmp596 __tmp606))
(let __tmp625 (Arg __tmp69 __tmp624))
(let __tmp626 (Get __tmp625 3))
(let __tmp627 (Get __tmp625 2))
(let __tmp628 (Bop __tmp67 __tmp626 __tmp627))
(let __tmp629 (Single __tmp628))
(let __tmp630 (Single __tmp626))
(let __tmp631 (Get __tmp625 1))
(let __tmp632 (Bop __tmp67 __tmp631 __tmp627))
(let __tmp633 (Single __tmp632))
(let __tmp634 (Get __tmp625 0))
(let __tmp635 (Single __tmp634))
(let __tmp636 (Concat __tmp633 __tmp635))
(let __tmp637 (Concat __tmp630 __tmp636))
(let __tmp638 (Call "ack" __tmp637))
(let __tmp639 (Get __tmp638 0))
(let __tmp640 (Single __tmp639))
(let __tmp641 (Get __tmp638 1))
(let __tmp642 (Single __tmp641))
(let __tmp643 (Concat __tmp640 __tmp642))
(let __tmp644 (Concat __tmp629 __tmp643))
(let __tmp645 (Call "ack" __tmp644))
(let __tmp646 (Get __tmp645 1))
(let __tmp647 (Single __tmp646))
(let __tmp648 (Get __tmp645 0))
(let __tmp649 (Single __tmp648))
(let __tmp650 (Concat __tmp647 __tmp649))
(let __tmp651 (If __tmp596 __tmp606 __tmp623 __tmp650))
(let __tmp652 (Get __tmp651 0))
(let __tmp653 (Single __tmp652))
(let __tmp654 (Get __tmp651 1))
(let __tmp655 (Single __tmp654))
(let __tmp656 (Concat __tmp653 __tmp655))
(let __tmp657 (If __tmp570 __tmp582 __tmp591 __tmp656))
(let __tmp658 (Get __tmp657 1))
(let __tmp659 (Single __tmp658))
(let __tmp660 (Get __tmp657 0))
(let __tmp661 (Single __tmp660))
(let __tmp662 (Concat __tmp659 __tmp661))
(let __tmp663 (Get __tmp107 0))
(let __tmp664 (Bop __tmp18 __tmp663 __tmp569))
(let __tmp665 (Get __tmp107 2))
(let __tmp666 (Single __tmp665))
(let __tmp667 (Get __tmp107 1))
(let __tmp668 (Single __tmp667))
(let __tmp669 (Single __tmp663))
(let __tmp670 (Concat __tmp669 __tmp578))
(let __tmp671 (Concat __tmp576 __tmp670))
(let __tmp672 (Concat __tmp668 __tmp671))
(let __tmp673 (Concat __tmp666 __tmp672))
(let __tmp674 (InIf true __tmp664 __tmp673))
(let __tmp675 (Arg __tmp41 __tmp674))
(let __tmp676 (Get __tmp675 0))
(let __tmp677 (Single __tmp676))
(let __tmp678 (Get __tmp675 1))
(let __tmp679 (Get __tmp675 2))
(let __tmp680 (Bop __tmp46 __tmp678 __tmp679))
(let __tmp681 (Single __tmp680))
(let __tmp682 (Concat __tmp677 __tmp681))
(let __tmp683 (InIf false __tmp664 __tmp673))
(let __tmp684 (Arg __tmp41 __tmp683))
(let __tmp685 (Get __tmp684 1))
(let __tmp686 (Get __tmp684 4))
(let __tmp687 (Bop __tmp18 __tmp685 __tmp686))
(let __tmp688 (Get __tmp684 0))
(let __tmp689 (Single __tmp688))
(let __tmp690 (Single __tmp685))
(let __tmp691 (Get __tmp684 2))
(let __tmp692 (Single __tmp691))
(let __tmp693 (Get __tmp684 3))
(let __tmp694 (Single __tmp693))
(let __tmp695 (Concat __tmp692 __tmp694))
(let __tmp696 (Concat __tmp690 __tmp695))
(let __tmp697 (Concat __tmp689 __tmp696))
(let __tmp698 (InIf true __tmp687 __tmp697))
(let __tmp699 (Arg __tmp69 __tmp698))
(let __tmp700 (Get __tmp699 3))
(let __tmp701 (Get __tmp699 2))
(let __tmp702 (Bop __tmp67 __tmp700 __tmp701))
(let __tmp703 (Single __tmp702))
(let __tmp704 (Single __tmp701))
(let __tmp705 (Get __tmp699 0))
(let __tmp706 (Single __tmp705))
(let __tmp707 (Concat __tmp704 __tmp706))
(let __tmp708 (Concat __tmp703 __tmp707))
(let __tmp709 (Call "ack" __tmp708))
(let __tmp710 (Get __tmp709 1))
(let __tmp711 (Single __tmp710))
(let __tmp712 (Get __tmp709 0))
(let __tmp713 (Single __tmp712))
(let __tmp714 (Concat __tmp711 __tmp713))
(let __tmp715 (InIf false __tmp687 __tmp697))
(let __tmp716 (Arg __tmp69 __tmp715))
(let __tmp717 (Get __tmp716 3))
(let __tmp718 (Get __tmp716 2))
(let __tmp719 (Bop __tmp67 __tmp717 __tmp718))
(let __tmp720 (Single __tmp719))
(let __tmp721 (Single __tmp717))
(let __tmp722 (Get __tmp716 1))
(let __tmp723 (Bop __tmp67 __tmp722 __tmp718))
(let __tmp724 (Single __tmp723))
(let __tmp725 (Get __tmp716 0))
(let __tmp726 (Single __tmp725))
(let __tmp727 (Concat __tmp724 __tmp726))
(let __tmp728 (Concat __tmp721 __tmp727))
(let __tmp729 (Call "ack" __tmp728))
(let __tmp730 (Get __tmp729 0))
(let __tmp731 (Single __tmp730))
(let __tmp732 (Get __tmp729 1))
(let __tmp733 (Single __tmp732))
(let __tmp734 (Concat __tmp731 __tmp733))
(let __tmp735 (Concat __tmp720 __tmp734))
(let __tmp736 (Call "ack" __tmp735))
(let __tmp737 (Get __tmp736 1))
(let __tmp738 (Single __tmp737))
(let __tmp739 (Get __tmp736 0))
(let __tmp740 (Single __tmp739))
(let __tmp741 (Concat __tmp738 __tmp740))
(let __tmp742 (If __tmp687 __tmp697 __tmp714 __tmp741))
(let __tmp743 (Get __tmp742 0))
(let __tmp744 (Single __tmp743))
(let __tmp745 (Get __tmp742 1))
(let __tmp746 (Single __tmp745))
(let __tmp747 (Concat __tmp744 __tmp746))
(let __tmp748 (If __tmp664 __tmp673 __tmp682 __tmp747))
(let __tmp749 (Get __tmp748 1))
(let __tmp750 (Single __tmp749))
(let __tmp751 (Get __tmp748 0))
(let __tmp752 (Single __tmp751))
(let __tmp753 (Concat __tmp750 __tmp752))
(let __tmp754 (Get __tmp219 0))
(let __tmp755 (Const __tmp20 __tmp69 __tmp209))
(let __tmp756 (Bop __tmp18 __tmp754 __tmp755))
(let __tmp757 (Get __tmp219 2))
(let __tmp758 (Single __tmp757))
(let __tmp759 (Get __tmp219 1))
(let __tmp760 (Single __tmp759))
(let __tmp761 (Const __tmp27 __tmp69 __tmp209))
(let __tmp762 (Single __tmp761))
(let __tmp763 (Single __tmp754))
(let __tmp764 (Single __tmp755))
(let __tmp765 (Concat __tmp763 __tmp764))
(let __tmp766 (Concat __tmp762 __tmp765))
(let __tmp767 (Concat __tmp760 __tmp766))
(let __tmp768 (Concat __tmp758 __tmp767))
(let __tmp769 (InIf true __tmp756 __tmp768))
(let __tmp770 (Arg __tmp41 __tmp769))
(let __tmp771 (Get __tmp770 0))
(let __tmp772 (Single __tmp771))
(let __tmp773 (Get __tmp770 1))
(let __tmp774 (Get __tmp770 2))
(let __tmp775 (Bop __tmp46 __tmp773 __tmp774))
(let __tmp776 (Single __tmp775))
(let __tmp777 (Concat __tmp772 __tmp776))
(let __tmp778 (InIf false __tmp756 __tmp768))
(let __tmp779 (Arg __tmp41 __tmp778))
(let __tmp780 (Get __tmp779 1))
(let __tmp781 (Get __tmp779 4))
(let __tmp782 (Bop __tmp18 __tmp780 __tmp781))
(let __tmp783 (Get __tmp779 0))
(let __tmp784 (Single __tmp783))
(let __tmp785 (Single __tmp780))
(let __tmp786 (Get __tmp779 2))
(let __tmp787 (Single __tmp786))
(let __tmp788 (Get __tmp779 3))
(let __tmp789 (Single __tmp788))
(let __tmp790 (Concat __tmp787 __tmp789))
(let __tmp791 (Concat __tmp785 __tmp790))
(let __tmp792 (Concat __tmp784 __tmp791))
(let __tmp793 (InIf true __tmp782 __tmp792))
(let __tmp794 (Arg __tmp69 __tmp793))
(let __tmp795 (Get __tmp794 3))
(let __tmp796 (Get __tmp794 2))
(let __tmp797 (Bop __tmp67 __tmp795 __tmp796))
(let __tmp798 (Single __tmp797))
(let __tmp799 (Single __tmp796))
(let __tmp800 (Get __tmp794 0))
(let __tmp801 (Single __tmp800))
(let __tmp802 (Concat __tmp799 __tmp801))
(let __tmp803 (Concat __tmp798 __tmp802))
(let __tmp804 (Call "ack" __tmp803))
(let __tmp805 (Get __tmp804 1))
(let __tmp806 (Single __tmp805))
(let __tmp807 (Get __tmp804 0))
(let __tmp808 (Single __tmp807))
(let __tmp809 (Concat __tmp806 __tmp808))
(let __tmp810 (InIf false __tmp782 __tmp792))
(let __tmp811 (Arg __tmp69 __tmp810))
(let __tmp812 (Get __tmp811 3))
(let __tmp813 (Get __tmp811 2))
(let __tmp814 (Bop __tmp67 __tmp812 __tmp813))
(let __tmp815 (Single __tmp814))
(let __tmp816 (Single __tmp812))
(let __tmp817 (Get __tmp811 1))
(let __tmp818 (Bop __tmp67 __tmp817 __tmp813))
(let __tmp819 (Single __tmp818))
(let __tmp820 (Get __tmp811 0))
(let __tmp821 (Single __tmp820))
(let __tmp822 (Concat __tmp819 __tmp821))
(let __tmp823 (Concat __tmp816 __tmp822))
(let __tmp824 (Call "ack" __tmp823))
(let __tmp825 (Get __tmp824 0))
(let __tmp826 (Single __tmp825))
(let __tmp827 (Get __tmp824 1))
(let __tmp828 (Single __tmp827))
(let __tmp829 (Concat __tmp826 __tmp828))
(let __tmp830 (Concat __tmp815 __tmp829))
(let __tmp831 (Call "ack" __tmp830))
(let __tmp832 (Get __tmp831 1))
(let __tmp833 (Single __tmp832))
(let __tmp834 (Get __tmp831 0))
(let __tmp835 (Single __tmp834))
(let __tmp836 (Concat __tmp833 __tmp835))
(let __tmp837 (If __tmp782 __tmp792 __tmp809 __tmp836))
(let __tmp838 (Get __tmp837 0))
(let __tmp839 (Single __tmp838))
(let __tmp840 (Get __tmp837 1))
(let __tmp841 (Single __tmp840))
(let __tmp842 (Concat __tmp839 __tmp841))
(let __tmp843 (If __tmp756 __tmp768 __tmp777 __tmp842))
(let __tmp844 (Get __tmp843 1))
(let __tmp845 (Single __tmp844))
(let __tmp846 (Get __tmp843 0))
(let __tmp847 (Single __tmp846))
(let __tmp848 (Concat __tmp845 __tmp847))
(let __tmp849 (Get __tmp239 0))
(let __tmp850 (Const __tmp20 __tmp69 __tmp226))
(let __tmp851 (Bop __tmp18 __tmp849 __tmp850))
(let __tmp852 (Get __tmp239 2))
(let __tmp853 (Single __tmp852))
(let __tmp854 (Get __tmp239 1))
(let __tmp855 (Single __tmp854))
(let __tmp856 (Const __tmp27 __tmp69 __tmp226))
(let __tmp857 (Single __tmp856))
(let __tmp858 (Single __tmp849))
(let __tmp859 (Single __tmp850))
(let __tmp860 (Concat __tmp858 __tmp859))
(let __tmp861 (Concat __tmp857 __tmp860))
(let __tmp862 (Concat __tmp855 __tmp861))
(let __tmp863 (Concat __tmp853 __tmp862))
(let __tmp864 (InIf true __tmp851 __tmp863))
(let __tmp865 (Arg __tmp41 __tmp864))
(let __tmp866 (Get __tmp865 0))
(let __tmp867 (Single __tmp866))
(let __tmp868 (Get __tmp865 1))
(let __tmp869 (Get __tmp865 2))
(let __tmp870 (Bop __tmp46 __tmp868 __tmp869))
(let __tmp871 (Single __tmp870))
(let __tmp872 (Concat __tmp867 __tmp871))
(let __tmp873 (InIf false __tmp851 __tmp863))
(let __tmp874 (Arg __tmp41 __tmp873))
(let __tmp875 (Get __tmp874 1))
(let __tmp876 (Get __tmp874 4))
(let __tmp877 (Bop __tmp18 __tmp875 __tmp876))
(let __tmp878 (Get __tmp874 0))
(let __tmp879 (Single __tmp878))
(let __tmp880 (Single __tmp875))
(let __tmp881 (Get __tmp874 2))
(let __tmp882 (Single __tmp881))
(let __tmp883 (Get __tmp874 3))
(let __tmp884 (Single __tmp883))
(let __tmp885 (Concat __tmp882 __tmp884))
(let __tmp886 (Concat __tmp880 __tmp885))
(let __tmp887 (Concat __tmp879 __tmp886))
(let __tmp888 (InIf true __tmp877 __tmp887))
(let __tmp889 (Arg __tmp69 __tmp888))
(let __tmp890 (Get __tmp889 3))
(let __tmp891 (Get __tmp889 2))
(let __tmp892 (Bop __tmp67 __tmp890 __tmp891))
(let __tmp893 (Single __tmp892))
(let __tmp894 (Single __tmp891))
(let __tmp895 (Get __tmp889 0))
(let __tmp896 (Single __tmp895))
(let __tmp897 (Concat __tmp894 __tmp896))
(let __tmp898 (Concat __tmp893 __tmp897))
(let __tmp899 (Call "ack" __tmp898))
(let __tmp900 (Get __tmp899 1))
(let __tmp901 (Single __tmp900))
(let __tmp902 (Get __tmp899 0))
(let __tmp903 (Single __tmp902))
(let __tmp904 (Concat __tmp901 __tmp903))
(let __tmp905 (InIf false __tmp877 __tmp887))
(let __tmp906 (Arg __tmp69 __tmp905))
(let __tmp907 (Get __tmp906 3))
(let __tmp908 (Get __tmp906 2))
(let __tmp909 (Bop __tmp67 __tmp907 __tmp908))
(let __tmp910 (Single __tmp909))
(let __tmp911 (Single __tmp907))
(let __tmp912 (Get __tmp906 1))
(let __tmp913 (Bop __tmp67 __tmp912 __tmp908))
(let __tmp914 (Single __tmp913))
(let __tmp915 (Get __tmp906 0))
(let __tmp916 (Single __tmp915))
(let __tmp917 (Concat __tmp914 __tmp916))
(let __tmp918 (Concat __tmp911 __tmp917))
(let __tmp919 (Call "ack" __tmp918))
(let __tmp920 (Get __tmp919 0))
(let __tmp921 (Single __tmp920))
(let __tmp922 (Get __tmp919 1))
(let __tmp923 (Single __tmp922))
(let __tmp924 (Concat __tmp921 __tmp923))
(let __tmp925 (Concat __tmp910 __tmp924))
(let __tmp926 (Call "ack" __tmp925))
(let __tmp927 (Get __tmp926 1))
(let __tmp928 (Single __tmp927))
(let __tmp929 (Get __tmp926 0))
(let __tmp930 (Single __tmp929))
(let __tmp931 (Concat __tmp928 __tmp930))
(let __tmp932 (If __tmp877 __tmp887 __tmp904 __tmp931))
(let __tmp933 (Get __tmp932 0))
(let __tmp934 (Single __tmp933))
(let __tmp935 (Get __tmp932 1))
(let __tmp936 (Single __tmp935))
(let __tmp937 (Concat __tmp934 __tmp936))
(let __tmp938 (If __tmp851 __tmp863 __tmp872 __tmp937))
(let __tmp939 (Get __tmp938 1))
(let __tmp940 (Single __tmp939))
(let __tmp941 (Get __tmp938 0))
(let __tmp942 (Single __tmp941))
(let __tmp943 (Concat __tmp940 __tmp942))
(let __tmp944 (Get __tmp246 0))
(let __tmp945 (Bop __tmp18 __tmp944 __tmp850))
(let __tmp946 (Get __tmp246 2))
(let __tmp947 (Single __tmp946))
(let __tmp948 (Get __tmp246 1))
(let __tmp949 (Single __tmp948))
(let __tmp950 (Single __tmp944))
(let __tmp951 (Concat __tmp950 __tmp859))
(let __tmp952 (Concat __tmp857 __tmp951))
(let __tmp953 (Concat __tmp949 __tmp952))
(let __tmp954 (Concat __tmp947 __tmp953))
(let __tmp955 (InIf true __tmp945 __tmp954))
(let __tmp956 (Arg __tmp41 __tmp955))
(let __tmp957 (Get __tmp956 0))
(let __tmp958 (Single __tmp957))
(let __tmp959 (Get __tmp956 1))
(let __tmp960 (Get __tmp956 2))
(let __tmp961 (Bop __tmp46 __tmp959 __tmp960))
(let __tmp962 (Single __tmp961))
(let __tmp963 (Concat __tmp958 __tmp962))
(let __tmp964 (InIf false __tmp945 __tmp954))
(let __tmp965 (Arg __tmp41 __tmp964))
(let __tmp966 (Get __tmp965 1))
(let __tmp967 (Get __tmp965 4))
(let __tmp968 (Bop __tmp18 __tmp966 __tmp967))
(let __tmp969 (Get __tmp965 0))
(let __tmp970 (Single __tmp969))
(let __tmp971 (Single __tmp966))
(let __tmp972 (Get __tmp965 2))
(let __tmp973 (Single __tmp972))
(let __tmp974 (Get __tmp965 3))
(let __tmp975 (Single __tmp974))
(let __tmp976 (Concat __tmp973 __tmp975))
(let __tmp977 (Concat __tmp971 __tmp976))
(let __tmp978 (Concat __tmp970 __tmp977))
(let __tmp979 (InIf true __tmp968 __tmp978))
(let __tmp980 (Arg __tmp69 __tmp979))
(let __tmp981 (Get __tmp980 3))
(let __tmp982 (Get __tmp980 2))
(let __tmp983 (Bop __tmp67 __tmp981 __tmp982))
(let __tmp984 (Single __tmp983))
(let __tmp985 (Single __tmp982))
(let __tmp986 (Get __tmp980 0))
(let __tmp987 (Single __tmp986))
(let __tmp988 (Concat __tmp985 __tmp987))
(let __tmp989 (Concat __tmp984 __tmp988))
(let __tmp990 (Call "ack" __tmp989))
(let __tmp991 (Get __tmp990 1))
(let __tmp992 (Single __tmp991))
(let __tmp993 (Get __tmp990 0))
(let __tmp994 (Single __tmp993))
(let __tmp995 (Concat __tmp992 __tmp994))
(let __tmp996 (InIf false __tmp968 __tmp978))
(let __tmp997 (Arg __tmp69 __tmp996))
(let __tmp998 (Get __tmp997 3))
(let __tmp999 (Get __tmp997 2))
(let __tmp1000 (Bop __tmp67 __tmp998 __tmp999))
(let __tmp1001 (Single __tmp1000))
(let __tmp1002 (Single __tmp998))
(let __tmp1003 (Get __tmp997 1))
(let __tmp1004 (Bop __tmp67 __tmp1003 __tmp999))
(let __tmp1005 (Single __tmp1004))
(let __tmp1006 (Get __tmp997 0))
(let __tmp1007 (Single __tmp1006))
(let __tmp1008 (Concat __tmp1005 __tmp1007))
(let __tmp1009 (Concat __tmp1002 __tmp1008))
(let __tmp1010 (Call "ack" __tmp1009))
(let __tmp1011 (Get __tmp1010 0))
(let __tmp1012 (Single __tmp1011))
(let __tmp1013 (Get __tmp1010 1))
(let __tmp1014 (Single __tmp1013))
(let __tmp1015 (Concat __tmp1012 __tmp1014))
(let __tmp1016 (Concat __tmp1001 __tmp1015))
(let __tmp1017 (Call "ack" __tmp1016))
(let __tmp1018 (Get __tmp1017 1))
(let __tmp1019 (Single __tmp1018))
(let __tmp1020 (Get __tmp1017 0))
(let __tmp1021 (Single __tmp1020))
(let __tmp1022 (Concat __tmp1019 __tmp1021))
(let __tmp1023 (If __tmp968 __tmp978 __tmp995 __tmp1022))
(let __tmp1024 (Get __tmp1023 0))
(let __tmp1025 (Single __tmp1024))
(let __tmp1026 (Get __tmp1023 1))
(let __tmp1027 (Single __tmp1026))
(let __tmp1028 (Concat __tmp1025 __tmp1027))
(let __tmp1029 (If __tmp945 __tmp954 __tmp963 __tmp1028))
(let __tmp1030 (Get __tmp1029 1))
(let __tmp1031 (Single __tmp1030))
(let __tmp1032 (Get __tmp1029 0))
(let __tmp1033 (Single __tmp1032))
(let __tmp1034 (Concat __tmp1031 __tmp1033))
(let __tmp1035 (Get __tmp327 0))
(let __tmp1036 (Const __tmp20 __tmp69 __tmp317))
(let __tmp1037 (Bop __tmp18 __tmp1035 __tmp1036))
(let __tmp1038 (Get __tmp327 2))
(let __tmp1039 (Single __tmp1038))
(let __tmp1040 (Get __tmp327 1))
(let __tmp1041 (Single __tmp1040))
(let __tmp1042 (Const __tmp27 __tmp69 __tmp317))
(let __tmp1043 (Single __tmp1042))
(let __tmp1044 (Single __tmp1035))
(let __tmp1045 (Single __tmp1036))
(let __tmp1046 (Concat __tmp1044 __tmp1045))
(let __tmp1047 (Concat __tmp1043 __tmp1046))
(let __tmp1048 (Concat __tmp1041 __tmp1047))
(let __tmp1049 (Concat __tmp1039 __tmp1048))
(let __tmp1050 (InIf true __tmp1037 __tmp1049))
(let __tmp1051 (Arg __tmp41 __tmp1050))
(let __tmp1052 (Get __tmp1051 0))
(let __tmp1053 (Single __tmp1052))
(let __tmp1054 (Get __tmp1051 1))
(let __tmp1055 (Get __tmp1051 2))
(let __tmp1056 (Bop __tmp46 __tmp1054 __tmp1055))
(let __tmp1057 (Single __tmp1056))
(let __tmp1058 (Concat __tmp1053 __tmp1057))
(let __tmp1059 (InIf false __tmp1037 __tmp1049))
(let __tmp1060 (Arg __tmp41 __tmp1059))
(let __tmp1061 (Get __tmp1060 1))
(let __tmp1062 (Get __tmp1060 4))
(let __tmp1063 (Bop __tmp18 __tmp1061 __tmp1062))
(let __tmp1064 (Get __tmp1060 0))
(let __tmp1065 (Single __tmp1064))
(let __tmp1066 (Single __tmp1061))
(let __tmp1067 (Get __tmp1060 2))
(let __tmp1068 (Single __tmp1067))
(let __tmp1069 (Get __tmp1060 3))
(let __tmp1070 (Single __tmp1069))
(let __tmp1071 (Concat __tmp1068 __tmp1070))
(let __tmp1072 (Concat __tmp1066 __tmp1071))
(let __tmp1073 (Concat __tmp1065 __tmp1072))
(let __tmp1074 (InIf true __tmp1063 __tmp1073))
(let __tmp1075 (Arg __tmp69 __tmp1074))
(let __tmp1076 (Get __tmp1075 3))
(let __tmp1077 (Get __tmp1075 2))
(let __tmp1078 (Bop __tmp67 __tmp1076 __tmp1077))
(let __tmp1079 (Single __tmp1078))
(let __tmp1080 (Single __tmp1077))
(let __tmp1081 (Get __tmp1075 0))
(let __tmp1082 (Single __tmp1081))
(let __tmp1083 (Concat __tmp1080 __tmp1082))
(let __tmp1084 (Concat __tmp1079 __tmp1083))
(let __tmp1085 (Call "ack" __tmp1084))
(let __tmp1086 (Get __tmp1085 1))
(let __tmp1087 (Single __tmp1086))
(let __tmp1088 (Get __tmp1085 0))
(let __tmp1089 (Single __tmp1088))
(let __tmp1090 (Concat __tmp1087 __tmp1089))
(let __tmp1091 (InIf false __tmp1063 __tmp1073))
(let __tmp1092 (Arg __tmp69 __tmp1091))
(let __tmp1093 (Get __tmp1092 3))
(let __tmp1094 (Get __tmp1092 2))
(let __tmp1095 (Bop __tmp67 __tmp1093 __tmp1094))
(let __tmp1096 (Single __tmp1095))
(let __tmp1097 (Single __tmp1093))
(let __tmp1098 (Get __tmp1092 1))
(let __tmp1099 (Bop __tmp67 __tmp1098 __tmp1094))
(let __tmp1100 (Single __tmp1099))
(let __tmp1101 (Get __tmp1092 0))
(let __tmp1102 (Single __tmp1101))
(let __tmp1103 (Concat __tmp1100 __tmp1102))
(let __tmp1104 (Concat __tmp1097 __tmp1103))
(let __tmp1105 (Call "ack" __tmp1104))
(let __tmp1106 (Get __tmp1105 0))
(let __tmp1107 (Single __tmp1106))
(let __tmp1108 (Get __tmp1105 1))
(let __tmp1109 (Single __tmp1108))
(let __tmp1110 (Concat __tmp1107 __tmp1109))
(let __tmp1111 (Concat __tmp1096 __tmp1110))
(let __tmp1112 (Call "ack" __tmp1111))
(let __tmp1113 (Get __tmp1112 1))
(let __tmp1114 (Single __tmp1113))
(let __tmp1115 (Get __tmp1112 0))
(let __tmp1116 (Single __tmp1115))
(let __tmp1117 (Concat __tmp1114 __tmp1116))
(let __tmp1118 (If __tmp1063 __tmp1073 __tmp1090 __tmp1117))
(let __tmp1119 (Get __tmp1118 0))
(let __tmp1120 (Single __tmp1119))
(let __tmp1121 (Get __tmp1118 1))
(let __tmp1122 (Single __tmp1121))
(let __tmp1123 (Concat __tmp1120 __tmp1122))
(let __tmp1124 (If __tmp1037 __tmp1049 __tmp1058 __tmp1123))
(let __tmp1125 (Get __tmp1124 1))
(let __tmp1126 (Single __tmp1125))
(let __tmp1127 (Get __tmp1124 0))
(let __tmp1128 (Single __tmp1127))
(let __tmp1129 (Concat __tmp1126 __tmp1128))
(let __tmp1130 (Get __tmp347 0))
(let __tmp1131 (Const __tmp20 __tmp69 __tmp334))
(let __tmp1132 (Bop __tmp18 __tmp1130 __tmp1131))
(let __tmp1133 (Get __tmp347 2))
(let __tmp1134 (Single __tmp1133))
(let __tmp1135 (Get __tmp347 1))
(let __tmp1136 (Single __tmp1135))
(let __tmp1137 (Const __tmp27 __tmp69 __tmp334))
(let __tmp1138 (Single __tmp1137))
(let __tmp1139 (Single __tmp1130))
(let __tmp1140 (Single __tmp1131))
(let __tmp1141 (Concat __tmp1139 __tmp1140))
(let __tmp1142 (Concat __tmp1138 __tmp1141))
(let __tmp1143 (Concat __tmp1136 __tmp1142))
(let __tmp1144 (Concat __tmp1134 __tmp1143))
(let __tmp1145 (InIf true __tmp1132 __tmp1144))
(let __tmp1146 (Arg __tmp41 __tmp1145))
(let __tmp1147 (Get __tmp1146 0))
(let __tmp1148 (Single __tmp1147))
(let __tmp1149 (Get __tmp1146 1))
(let __tmp1150 (Get __tmp1146 2))
(let __tmp1151 (Bop __tmp46 __tmp1149 __tmp1150))
(let __tmp1152 (Single __tmp1151))
(let __tmp1153 (Concat __tmp1148 __tmp1152))
(let __tmp1154 (InIf false __tmp1132 __tmp1144))
(let __tmp1155 (Arg __tmp41 __tmp1154))
(let __tmp1156 (Get __tmp1155 1))
(let __tmp1157 (Get __tmp1155 4))
(let __tmp1158 (Bop __tmp18 __tmp1156 __tmp1157))
(let __tmp1159 (Get __tmp1155 0))
(let __tmp1160 (Single __tmp1159))
(let __tmp1161 (Single __tmp1156))
(let __tmp1162 (Get __tmp1155 2))
(let __tmp1163 (Single __tmp1162))
(let __tmp1164 (Get __tmp1155 3))
(let __tmp1165 (Single __tmp1164))
(let __tmp1166 (Concat __tmp1163 __tmp1165))
(let __tmp1167 (Concat __tmp1161 __tmp1166))
(let __tmp1168 (Concat __tmp1160 __tmp1167))
(let __tmp1169 (InIf true __tmp1158 __tmp1168))
(let __tmp1170 (Arg __tmp69 __tmp1169))
(let __tmp1171 (Get __tmp1170 3))
(let __tmp1172 (Get __tmp1170 2))
(let __tmp1173 (Bop __tmp67 __tmp1171 __tmp1172))
(let __tmp1174 (Single __tmp1173))
(let __tmp1175 (Single __tmp1172))
(let __tmp1176 (Get __tmp1170 0))
(let __tmp1177 (Single __tmp1176))
(let __tmp1178 (Concat __tmp1175 __tmp1177))
(let __tmp1179 (Concat __tmp1174 __tmp1178))
(let __tmp1180 (Call "ack" __tmp1179))
(let __tmp1181 (Get __tmp1180 1))
(let __tmp1182 (Single __tmp1181))
(let __tmp1183 (Get __tmp1180 0))
(let __tmp1184 (Single __tmp1183))
(let __tmp1185 (Concat __tmp1182 __tmp1184))
(let __tmp1186 (InIf false __tmp1158 __tmp1168))
(let __tmp1187 (Arg __tmp69 __tmp1186))
(let __tmp1188 (Get __tmp1187 3))
(let __tmp1189 (Get __tmp1187 2))
(let __tmp1190 (Bop __tmp67 __tmp1188 __tmp1189))
(let __tmp1191 (Single __tmp1190))
(let __tmp1192 (Single __tmp1188))
(let __tmp1193 (Get __tmp1187 1))
(let __tmp1194 (Bop __tmp67 __tmp1193 __tmp1189))
(let __tmp1195 (Single __tmp1194))
(let __tmp1196 (Get __tmp1187 0))
(let __tmp1197 (Single __tmp1196))
(let __tmp1198 (Concat __tmp1195 __tmp1197))
(let __tmp1199 (Concat __tmp1192 __tmp1198))
(let __tmp1200 (Call "ack" __tmp1199))
(let __tmp1201 (Get __tmp1200 0))
(let __tmp1202 (Single __tmp1201))
(let __tmp1203 (Get __tmp1200 1))
(let __tmp1204 (Single __tmp1203))
(let __tmp1205 (Concat __tmp1202 __tmp1204))
(let __tmp1206 (Concat __tmp1191 __tmp1205))
(let __tmp1207 (Call "ack" __tmp1206))
(let __tmp1208 (Get __tmp1207 1))
(let __tmp1209 (Single __tmp1208))
(let __tmp1210 (Get __tmp1207 0))
(let __tmp1211 (Single __tmp1210))
(let __tmp1212 (Concat __tmp1209 __tmp1211))
(let __tmp1213 (If __tmp1158 __tmp1168 __tmp1185 __tmp1212))
(let __tmp1214 (Get __tmp1213 0))
(let __tmp1215 (Single __tmp1214))
(let __tmp1216 (Get __tmp1213 1))
(let __tmp1217 (Single __tmp1216))
(let __tmp1218 (Concat __tmp1215 __tmp1217))
(let __tmp1219 (If __tmp1132 __tmp1144 __tmp1153 __tmp1218))
(let __tmp1220 (Get __tmp1219 1))
(let __tmp1221 (Single __tmp1220))
(let __tmp1222 (Get __tmp1219 0))
(let __tmp1223 (Single __tmp1222))
(let __tmp1224 (Concat __tmp1221 __tmp1223))
(let __tmp1225 (Get __tmp354 0))
(let __tmp1226 (Bop __tmp18 __tmp1225 __tmp1131))
(let __tmp1227 (Get __tmp354 2))
(let __tmp1228 (Single __tmp1227))
(let __tmp1229 (Get __tmp354 1))
(let __tmp1230 (Single __tmp1229))
(let __tmp1231 (Single __tmp1225))
(let __tmp1232 (Concat __tmp1231 __tmp1140))
(let __tmp1233 (Concat __tmp1138 __tmp1232))
(let __tmp1234 (Concat __tmp1230 __tmp1233))
(let __tmp1235 (Concat __tmp1228 __tmp1234))
(let __tmp1236 (InIf true __tmp1226 __tmp1235))
(let __tmp1237 (Arg __tmp41 __tmp1236))
(let __tmp1238 (Get __tmp1237 0))
(let __tmp1239 (Single __tmp1238))
(let __tmp1240 (Get __tmp1237 1))
(let __tmp1241 (Get __tmp1237 2))
(let __tmp1242 (Bop __tmp46 __tmp1240 __tmp1241))
(let __tmp1243 (Single __tmp1242))
(let __tmp1244 (Concat __tmp1239 __tmp1243))
(let __tmp1245 (InIf false __tmp1226 __tmp1235))
(let __tmp1246 (Arg __tmp41 __tmp1245))
(let __tmp1247 (Get __tmp1246 1))
(let __tmp1248 (Get __tmp1246 4))
(let __tmp1249 (Bop __tmp18 __tmp1247 __tmp1248))
(let __tmp1250 (Get __tmp1246 0))
(let __tmp1251 (Single __tmp1250))
(let __tmp1252 (Single __tmp1247))
(let __tmp1253 (Get __tmp1246 2))
(let __tmp1254 (Single __tmp1253))
(let __tmp1255 (Get __tmp1246 3))
(let __tmp1256 (Single __tmp1255))
(let __tmp1257 (Concat __tmp1254 __tmp1256))
(let __tmp1258 (Concat __tmp1252 __tmp1257))
(let __tmp1259 (Concat __tmp1251 __tmp1258))
(let __tmp1260 (InIf true __tmp1249 __tmp1259))
(let __tmp1261 (Arg __tmp69 __tmp1260))
(let __tmp1262 (Get __tmp1261 3))
(let __tmp1263 (Get __tmp1261 2))
(let __tmp1264 (Bop __tmp67 __tmp1262 __tmp1263))
(let __tmp1265 (Single __tmp1264))
(let __tmp1266 (Single __tmp1263))
(let __tmp1267 (Get __tmp1261 0))
(let __tmp1268 (Single __tmp1267))
(let __tmp1269 (Concat __tmp1266 __tmp1268))
(let __tmp1270 (Concat __tmp1265 __tmp1269))
(let __tmp1271 (Call "ack" __tmp1270))
(let __tmp1272 (Get __tmp1271 1))
(let __tmp1273 (Single __tmp1272))
(let __tmp1274 (Get __tmp1271 0))
(let __tmp1275 (Single __tmp1274))
(let __tmp1276 (Concat __tmp1273 __tmp1275))
(let __tmp1277 (InIf false __tmp1249 __tmp1259))
(let __tmp1278 (Arg __tmp69 __tmp1277))
(let __tmp1279 (Get __tmp1278 3))
(let __tmp1280 (Get __tmp1278 2))
(let __tmp1281 (Bop __tmp67 __tmp1279 __tmp1280))
(let __tmp1282 (Single __tmp1281))
(let __tmp1283 (Single __tmp1279))
(let __tmp1284 (Get __tmp1278 1))
(let __tmp1285 (Bop __tmp67 __tmp1284 __tmp1280))
(let __tmp1286 (Single __tmp1285))
(let __tmp1287 (Get __tmp1278 0))
(let __tmp1288 (Single __tmp1287))
(let __tmp1289 (Concat __tmp1286 __tmp1288))
(let __tmp1290 (Concat __tmp1283 __tmp1289))
(let __tmp1291 (Call "ack" __tmp1290))
(let __tmp1292 (Get __tmp1291 0))
(let __tmp1293 (Single __tmp1292))
(let __tmp1294 (Get __tmp1291 1))
(let __tmp1295 (Single __tmp1294))
(let __tmp1296 (Concat __tmp1293 __tmp1295))
(let __tmp1297 (Concat __tmp1282 __tmp1296))
(let __tmp1298 (Call "ack" __tmp1297))
(let __tmp1299 (Get __tmp1298 1))
(let __tmp1300 (Single __tmp1299))
(let __tmp1301 (Get __tmp1298 0))
(let __tmp1302 (Single __tmp1301))
(let __tmp1303 (Concat __tmp1300 __tmp1302))
(let __tmp1304 (If __tmp1249 __tmp1259 __tmp1276 __tmp1303))
(let __tmp1305 (Get __tmp1304 0))
(let __tmp1306 (Single __tmp1305))
(let __tmp1307 (Get __tmp1304 1))
(let __tmp1308 (Single __tmp1307))
(let __tmp1309 (Concat __tmp1306 __tmp1308))
(let __tmp1310 (If __tmp1226 __tmp1235 __tmp1244 __tmp1309))
(let __tmp1311 (Get __tmp1310 1))
(let __tmp1312 (Single __tmp1311))
(let __tmp1313 (Get __tmp1310 0))
(let __tmp1314 (Single __tmp1313))
(let __tmp1315 (Concat __tmp1312 __tmp1314))
(let __tmp1316 (Get __tmp427 0))
(let __tmp1317 (Const __tmp20 __tmp69 __tmp417))
(let __tmp1318 (Bop __tmp18 __tmp1316 __tmp1317))
(let __tmp1319 (Get __tmp427 2))
(let __tmp1320 (Single __tmp1319))
(let __tmp1321 (Get __tmp427 1))
(let __tmp1322 (Single __tmp1321))
(let __tmp1323 (Const __tmp27 __tmp69 __tmp417))
(let __tmp1324 (Single __tmp1323))
(let __tmp1325 (Single __tmp1316))
(let __tmp1326 (Single __tmp1317))
(let __tmp1327 (Concat __tmp1325 __tmp1326))
(let __tmp1328 (Concat __tmp1324 __tmp1327))
(let __tmp1329 (Concat __tmp1322 __tmp1328))
(let __tmp1330 (Concat __tmp1320 __tmp1329))
(let __tmp1331 (InIf true __tmp1318 __tmp1330))
(let __tmp1332 (Arg __tmp41 __tmp1331))
(let __tmp1333 (Get __tmp1332 0))
(let __tmp1334 (Single __tmp1333))
(let __tmp1335 (Get __tmp1332 1))
(let __tmp1336 (Get __tmp1332 2))
(let __tmp1337 (Bop __tmp46 __tmp1335 __tmp1336))
(let __tmp1338 (Single __tmp1337))
(let __tmp1339 (Concat __tmp1334 __tmp1338))
(let __tmp1340 (InIf false __tmp1318 __tmp1330))
(let __tmp1341 (Arg __tmp41 __tmp1340))
(let __tmp1342 (Get __tmp1341 1))
(let __tmp1343 (Get __tmp1341 4))
(let __tmp1344 (Bop __tmp18 __tmp1342 __tmp1343))
(let __tmp1345 (Get __tmp1341 0))
(let __tmp1346 (Single __tmp1345))
(let __tmp1347 (Single __tmp1342))
(let __tmp1348 (Get __tmp1341 2))
(let __tmp1349 (Single __tmp1348))
(let __tmp1350 (Get __tmp1341 3))
(let __tmp1351 (Single __tmp1350))
(let __tmp1352 (Concat __tmp1349 __tmp1351))
(let __tmp1353 (Concat __tmp1347 __tmp1352))
(let __tmp1354 (Concat __tmp1346 __tmp1353))
(let __tmp1355 (InIf true __tmp1344 __tmp1354))
(let __tmp1356 (Arg __tmp69 __tmp1355))
(let __tmp1357 (Get __tmp1356 3))
(let __tmp1358 (Get __tmp1356 2))
(let __tmp1359 (Bop __tmp67 __tmp1357 __tmp1358))
(let __tmp1360 (Single __tmp1359))
(let __tmp1361 (Single __tmp1358))
(let __tmp1362 (Get __tmp1356 0))
(let __tmp1363 (Single __tmp1362))
(let __tmp1364 (Concat __tmp1361 __tmp1363))
(let __tmp1365 (Concat __tmp1360 __tmp1364))
(let __tmp1366 (Call "ack" __tmp1365))
(let __tmp1367 (Get __tmp1366 1))
(let __tmp1368 (Single __tmp1367))
(let __tmp1369 (Get __tmp1366 0))
(let __tmp1370 (Single __tmp1369))
(let __tmp1371 (Concat __tmp1368 __tmp1370))
(let __tmp1372 (InIf false __tmp1344 __tmp1354))
(let __tmp1373 (Arg __tmp69 __tmp1372))
(let __tmp1374 (Get __tmp1373 3))
(let __tmp1375 (Get __tmp1373 2))
(let __tmp1376 (Bop __tmp67 __tmp1374 __tmp1375))
(let __tmp1377 (Single __tmp1376))
(let __tmp1378 (Single __tmp1374))
(let __tmp1379 (Get __tmp1373 1))
(let __tmp1380 (Bop __tmp67 __tmp1379 __tmp1375))
(let __tmp1381 (Single __tmp1380))
(let __tmp1382 (Get __tmp1373 0))
(let __tmp1383 (Single __tmp1382))
(let __tmp1384 (Concat __tmp1381 __tmp1383))
(let __tmp1385 (Concat __tmp1378 __tmp1384))
(let __tmp1386 (Call "ack" __tmp1385))
(let __tmp1387 (Get __tmp1386 0))
(let __tmp1388 (Single __tmp1387))
(let __tmp1389 (Get __tmp1386 1))
(let __tmp1390 (Single __tmp1389))
(let __tmp1391 (Concat __tmp1388 __tmp1390))
(let __tmp1392 (Concat __tmp1377 __tmp1391))
(let __tmp1393 (Call "ack" __tmp1392))
(let __tmp1394 (Get __tmp1393 1))
(let __tmp1395 (Single __tmp1394))
(let __tmp1396 (Get __tmp1393 0))
(let __tmp1397 (Single __tmp1396))
(let __tmp1398 (Concat __tmp1395 __tmp1397))
(let __tmp1399 (If __tmp1344 __tmp1354 __tmp1371 __tmp1398))
(let __tmp1400 (Get __tmp1399 0))
(let __tmp1401 (Single __tmp1400))
(let __tmp1402 (Get __tmp1399 1))
(let __tmp1403 (Single __tmp1402))
(let __tmp1404 (Concat __tmp1401 __tmp1403))
(let __tmp1405 (If __tmp1318 __tmp1330 __tmp1339 __tmp1404))
(let __tmp1406 (Get __tmp1405 1))
(let __tmp1407 (Single __tmp1406))
(let __tmp1408 (Get __tmp1405 0))
(let __tmp1409 (Single __tmp1408))
(let __tmp1410 (Concat __tmp1407 __tmp1409))
(let __tmp1411 (Get __tmp447 0))
(let __tmp1412 (Const __tmp20 __tmp69 __tmp434))
(let __tmp1413 (Bop __tmp18 __tmp1411 __tmp1412))
(let __tmp1414 (Get __tmp447 2))
(let __tmp1415 (Single __tmp1414))
(let __tmp1416 (Get __tmp447 1))
(let __tmp1417 (Single __tmp1416))
(let __tmp1418 (Const __tmp27 __tmp69 __tmp434))
(let __tmp1419 (Single __tmp1418))
(let __tmp1420 (Single __tmp1411))
(let __tmp1421 (Single __tmp1412))
(let __tmp1422 (Concat __tmp1420 __tmp1421))
(let __tmp1423 (Concat __tmp1419 __tmp1422))
(let __tmp1424 (Concat __tmp1417 __tmp1423))
(let __tmp1425 (Concat __tmp1415 __tmp1424))
(let __tmp1426 (InIf true __tmp1413 __tmp1425))
(let __tmp1427 (Arg __tmp41 __tmp1426))
(let __tmp1428 (Get __tmp1427 0))
(let __tmp1429 (Single __tmp1428))
(let __tmp1430 (Get __tmp1427 1))
(let __tmp1431 (Get __tmp1427 2))
(let __tmp1432 (Bop __tmp46 __tmp1430 __tmp1431))
(let __tmp1433 (Single __tmp1432))
(let __tmp1434 (Concat __tmp1429 __tmp1433))
(let __tmp1435 (InIf false __tmp1413 __tmp1425))
(let __tmp1436 (Arg __tmp41 __tmp1435))
(let __tmp1437 (Get __tmp1436 1))
(let __tmp1438 (Get __tmp1436 4))
(let __tmp1439 (Bop __tmp18 __tmp1437 __tmp1438))
(let __tmp1440 (Get __tmp1436 0))
(let __tmp1441 (Single __tmp1440))
(let __tmp1442 (Single __tmp1437))
(let __tmp1443 (Get __tmp1436 2))
(let __tmp1444 (Single __tmp1443))
(let __tmp1445 (Get __tmp1436 3))
(let __tmp1446 (Single __tmp1445))
(let __tmp1447 (Concat __tmp1444 __tmp1446))
(let __tmp1448 (Concat __tmp1442 __tmp1447))
(let __tmp1449 (Concat __tmp1441 __tmp1448))
(let __tmp1450 (InIf true __tmp1439 __tmp1449))
(let __tmp1451 (Arg __tmp69 __tmp1450))
(let __tmp1452 (Get __tmp1451 3))
(let __tmp1453 (Get __tmp1451 2))
(let __tmp1454 (Bop __tmp67 __tmp1452 __tmp1453))
(let __tmp1455 (Single __tmp1454))
(let __tmp1456 (Single __tmp1453))
(let __tmp1457 (Get __tmp1451 0))
(let __tmp1458 (Single __tmp1457))
(let __tmp1459 (Concat __tmp1456 __tmp1458))
(let __tmp1460 (Concat __tmp1455 __tmp1459))
(let __tmp1461 (Call "ack" __tmp1460))
(let __tmp1462 (Get __tmp1461 1))
(let __tmp1463 (Single __tmp1462))
(let __tmp1464 (Get __tmp1461 0))
(let __tmp1465 (Single __tmp1464))
(let __tmp1466 (Concat __tmp1463 __tmp1465))
(let __tmp1467 (InIf false __tmp1439 __tmp1449))
(let __tmp1468 (Arg __tmp69 __tmp1467))
(let __tmp1469 (Get __tmp1468 3))
(let __tmp1470 (Get __tmp1468 2))
(let __tmp1471 (Bop __tmp67 __tmp1469 __tmp1470))
(let __tmp1472 (Single __tmp1471))
(let __tmp1473 (Single __tmp1469))
(let __tmp1474 (Get __tmp1468 1))
(let __tmp1475 (Bop __tmp67 __tmp1474 __tmp1470))
(let __tmp1476 (Single __tmp1475))
(let __tmp1477 (Get __tmp1468 0))
(let __tmp1478 (Single __tmp1477))
(let __tmp1479 (Concat __tmp1476 __tmp1478))
(let __tmp1480 (Concat __tmp1473 __tmp1479))
(let __tmp1481 (Call "ack" __tmp1480))
(let __tmp1482 (Get __tmp1481 0))
(let __tmp1483 (Single __tmp1482))
(let __tmp1484 (Get __tmp1481 1))
(let __tmp1485 (Single __tmp1484))
(let __tmp1486 (Concat __tmp1483 __tmp1485))
(let __tmp1487 (Concat __tmp1472 __tmp1486))
(let __tmp1488 (Call "ack" __tmp1487))
(let __tmp1489 (Get __tmp1488 1))
(let __tmp1490 (Single __tmp1489))
(let __tmp1491 (Get __tmp1488 0))
(let __tmp1492 (Single __tmp1491))
(let __tmp1493 (Concat __tmp1490 __tmp1492))
(let __tmp1494 (If __tmp1439 __tmp1449 __tmp1466 __tmp1493))
(let __tmp1495 (Get __tmp1494 0))
(let __tmp1496 (Single __tmp1495))
(let __tmp1497 (Get __tmp1494 1))
(let __tmp1498 (Single __tmp1497))
(let __tmp1499 (Concat __tmp1496 __tmp1498))
(let __tmp1500 (If __tmp1413 __tmp1425 __tmp1434 __tmp1499))
(let __tmp1501 (Get __tmp1500 1))
(let __tmp1502 (Single __tmp1501))
(let __tmp1503 (Get __tmp1500 0))
(let __tmp1504 (Single __tmp1503))
(let __tmp1505 (Concat __tmp1502 __tmp1504))
(let __tmp1506 (Get __tmp454 0))
(let __tmp1507 (Bop __tmp18 __tmp1506 __tmp1412))
(let __tmp1508 (Get __tmp454 2))
(let __tmp1509 (Single __tmp1508))
(let __tmp1510 (Get __tmp454 1))
(let __tmp1511 (Single __tmp1510))
(let __tmp1512 (Single __tmp1506))
(let __tmp1513 (Concat __tmp1512 __tmp1421))
(let __tmp1514 (Concat __tmp1419 __tmp1513))
(let __tmp1515 (Concat __tmp1511 __tmp1514))
(let __tmp1516 (Concat __tmp1509 __tmp1515))
(let __tmp1517 (InIf true __tmp1507 __tmp1516))
(let __tmp1518 (Arg __tmp41 __tmp1517))
(let __tmp1519 (Get __tmp1518 0))
(let __tmp1520 (Single __tmp1519))
(let __tmp1521 (Get __tmp1518 1))
(let __tmp1522 (Get __tmp1518 2))
(let __tmp1523 (Bop __tmp46 __tmp1521 __tmp1522))
(let __tmp1524 (Single __tmp1523))
(let __tmp1525 (Concat __tmp1520 __tmp1524))
(let __tmp1526 (InIf false __tmp1507 __tmp1516))
(let __tmp1527 (Arg __tmp41 __tmp1526))
(let __tmp1528 (Get __tmp1527 1))
(let __tmp1529 (Get __tmp1527 4))
(let __tmp1530 (Bop __tmp18 __tmp1528 __tmp1529))
(let __tmp1531 (Get __tmp1527 0))
(let __tmp1532 (Single __tmp1531))
(let __tmp1533 (Single __tmp1528))
(let __tmp1534 (Get __tmp1527 2))
(let __tmp1535 (Single __tmp1534))
(let __tmp1536 (Get __tmp1527 3))
(let __tmp1537 (Single __tmp1536))
(let __tmp1538 (Concat __tmp1535 __tmp1537))
(let __tmp1539 (Concat __tmp1533 __tmp1538))
(let __tmp1540 (Concat __tmp1532 __tmp1539))
(let __tmp1541 (InIf true __tmp1530 __tmp1540))
(let __tmp1542 (Arg __tmp69 __tmp1541))
(let __tmp1543 (Get __tmp1542 3))
(let __tmp1544 (Get __tmp1542 2))
(let __tmp1545 (Bop __tmp67 __tmp1543 __tmp1544))
(let __tmp1546 (Single __tmp1545))
(let __tmp1547 (Single __tmp1544))
(let __tmp1548 (Get __tmp1542 0))
(let __tmp1549 (Single __tmp1548))
(let __tmp1550 (Concat __tmp1547 __tmp1549))
(let __tmp1551 (Concat __tmp1546 __tmp1550))
(let __tmp1552 (Call "ack" __tmp1551))
(let __tmp1553 (Get __tmp1552 1))
(let __tmp1554 (Single __tmp1553))
(let __tmp1555 (Get __tmp1552 0))
(let __tmp1556 (Single __tmp1555))
(let __tmp1557 (Concat __tmp1554 __tmp1556))
(let __tmp1558 (InIf false __tmp1530 __tmp1540))
(let __tmp1559 (Arg __tmp69 __tmp1558))
(let __tmp1560 (Get __tmp1559 3))
(let __tmp1561 (Get __tmp1559 2))
(let __tmp1562 (Bop __tmp67 __tmp1560 __tmp1561))
(let __tmp1563 (Single __tmp1562))
(let __tmp1564 (Single __tmp1560))
(let __tmp1565 (Get __tmp1559 1))
(let __tmp1566 (Bop __tmp67 __tmp1565 __tmp1561))
(let __tmp1567 (Single __tmp1566))
(let __tmp1568 (Get __tmp1559 0))
(let __tmp1569 (Single __tmp1568))
(let __tmp1570 (Concat __tmp1567 __tmp1569))
(let __tmp1571 (Concat __tmp1564 __tmp1570))
(let __tmp1572 (Call "ack" __tmp1571))
(let __tmp1573 (Get __tmp1572 0))
(let __tmp1574 (Single __tmp1573))
(let __tmp1575 (Get __tmp1572 1))
(let __tmp1576 (Single __tmp1575))
(let __tmp1577 (Concat __tmp1574 __tmp1576))
(let __tmp1578 (Concat __tmp1563 __tmp1577))
(let __tmp1579 (Call "ack" __tmp1578))
(let __tmp1580 (Get __tmp1579 1))
(let __tmp1581 (Single __tmp1580))
(let __tmp1582 (Get __tmp1579 0))
(let __tmp1583 (Single __tmp1582))
(let __tmp1584 (Concat __tmp1581 __tmp1583))
(let __tmp1585 (If __tmp1530 __tmp1540 __tmp1557 __tmp1584))
(let __tmp1586 (Get __tmp1585 0))
(let __tmp1587 (Single __tmp1586))
(let __tmp1588 (Get __tmp1585 1))
(let __tmp1589 (Single __tmp1588))
(let __tmp1590 (Concat __tmp1587 __tmp1589))
(let __tmp1591 (If __tmp1507 __tmp1516 __tmp1525 __tmp1590))
(let __tmp1592 (Get __tmp1591 1))
(let __tmp1593 (Single __tmp1592))
(let __tmp1594 (Get __tmp1591 0))
(let __tmp1595 (Single __tmp1594))
(let __tmp1596 (Concat __tmp1593 __tmp1595))
(let __tmp1597 (TupleT __tmp3))
(let __tmp1598 (Print ))
(let __tmp1599 (Get __tmp17 0))
(let __tmp1600 (Get __tmp17 1))
(let __tmp1601 (Bop __tmp1598 __tmp1599 __tmp1600))
(let __tmp1602 (Single __tmp1601))
(let __tmp1603 (Function "main" __tmp6 __tmp1597 __tmp1602))
(let __tmp1604 (TupleT __tmp4))
(let __tmp1605 (InIf true __tmp130 __tmp142))
(let __tmp1606 (Arg __tmp41 __tmp1605))
(let __tmp1607 (Get __tmp1606 0))
(let __tmp1608 (Single __tmp1607))
(let __tmp1609 (Get __tmp1606 1))
(let __tmp1610 (Get __tmp1606 2))
(let __tmp1611 (Bop __tmp46 __tmp1609 __tmp1610))
(let __tmp1612 (Single __tmp1611))
(let __tmp1613 (Concat __tmp1608 __tmp1612))
(let __tmp1614 (Get __tmp169 1))
(let __tmp1615 (Single __tmp1614))
(let __tmp1616 (Get __tmp169 0))
(let __tmp1617 (Single __tmp1616))
(let __tmp1618 (Concat __tmp1615 __tmp1617))
(let __tmp1619 (Get __tmp381 1))
(let __tmp1620 (Single __tmp1619))
(let __tmp1621 (Get __tmp381 0))
(let __tmp1622 (Single __tmp1621))
(let __tmp1623 (Concat __tmp1620 __tmp1622))
(let __tmp1624 (If __tmp147 __tmp157 __tmp1618 __tmp1623))
(let __tmp1625 (Get __tmp1624 0))
(let __tmp1626 (Single __tmp1625))
(let __tmp1627 (Get __tmp1624 1))
(let __tmp1628 (Single __tmp1627))
(let __tmp1629 (Concat __tmp1626 __tmp1628))
(let __tmp1630 (If __tmp130 __tmp142 __tmp1613 __tmp1629))
(let __tmp1631 (Get __tmp1630 1))
(let __tmp1632 (Single __tmp1631))
(let __tmp1633 (Get __tmp1630 0))
(let __tmp1634 (Single __tmp1633))
(let __tmp1635 (Concat __tmp1632 __tmp1634))
(let __tmp1636 (Function "ack" __tmp6 __tmp1604 __tmp1635))
(let __tmp1637 (Nil ))
(let __tmp1638 (Cons __tmp1636 __tmp1637))
(let __tmp1639 (Program __tmp1603 __tmp1638))

; Program root
(let PROG __tmp1639)

; Loop context unions


; Function inlining unions
(relation InlinedCall (String Expr))
(union __tmp17 __tmp125)
(InlinedCall "ack" __tmp16)
(subsume (Call "ack" __tmp16))


(union __tmp169 __tmp264)
(InlinedCall "ack" __tmp168)
(subsume (Call "ack" __tmp168))


(union __tmp277 __tmp372)
(InlinedCall "ack" __tmp276)
(subsume (Call "ack" __tmp276))


(union __tmp381 __tmp472)
(InlinedCall "ack" __tmp380)
(subsume (Call "ack" __tmp380))


(union __tmp81 __tmp567)
(InlinedCall "ack" __tmp80)
(subsume (Call "ack" __tmp80))


(union __tmp101 __tmp662)
(InlinedCall "ack" __tmp100)
(subsume (Call "ack" __tmp100))


(union __tmp108 __tmp753)
(InlinedCall "ack" __tmp107)
(subsume (Call "ack" __tmp107))


(union __tmp220 __tmp848)
(InlinedCall "ack" __tmp219)
(subsume (Call "ack" __tmp219))


(union __tmp240 __tmp943)
(InlinedCall "ack" __tmp239)
(subsume (Call "ack" __tmp239))


(union __tmp247 __tmp1034)
(InlinedCall "ack" __tmp246)
(subsume (Call "ack" __tmp246))


(union __tmp328 __tmp1129)
(InlinedCall "ack" __tmp327)
(subsume (Call "ack" __tmp327))


(union __tmp348 __tmp1224)
(InlinedCall "ack" __tmp347)
(subsume (Call "ack" __tmp347))


(union __tmp355 __tmp1315)
(InlinedCall "ack" __tmp354)
(subsume (Call "ack" __tmp354))


(union __tmp428 __tmp1410)
(InlinedCall "ack" __tmp427)
(subsume (Call "ack" __tmp427))


(union __tmp448 __tmp1505)
(InlinedCall "ack" __tmp447)
(subsume (Call "ack" __tmp447))


(union __tmp455 __tmp1596)
(InlinedCall "ack" __tmp454)
(subsume (Call "ack" __tmp454))


; Schedule

(run-schedule

    (repeat 3

(saturate

    (saturate type-helpers)
    (saturate error-checking)
    state-edge-passthrough

    (saturate
        (saturate type-helpers)
        (saturate error-checking)
        saturating
    )

    (saturate drop)
    apply-drop-unions
    cleanup-drop

    (saturate
        (saturate type-helpers)
        (saturate error-checking)
        saturating
    )

    (saturate subst)
    apply-subst-unions
    cleanup-subst

    subsume-after-helpers

    (saturate boundary-analysis)
)
        all-optimizations
    )

    (repeat 4

(saturate

    (saturate type-helpers)
    (saturate error-checking)
    state-edge-passthrough

    (saturate
        (saturate type-helpers)
        (saturate error-checking)
        saturating
    )

    (saturate drop)
    apply-drop-unions
    cleanup-drop

    (saturate
        (saturate type-helpers)
        (saturate error-checking)
        saturating
    )

    (saturate subst)
    apply-subst-unions
    cleanup-subst

    subsume-after-helpers

    (saturate boundary-analysis)
)
        cheap-optimizations
    )


(saturate

    (saturate type-helpers)
    (saturate error-checking)
    state-edge-passthrough

    (saturate
        (saturate type-helpers)
        (saturate error-checking)
        saturating
    )

    (saturate drop)
    apply-drop-unions
    cleanup-drop

    (saturate
        (saturate type-helpers)
        (saturate error-checking)
        saturating
    )

    (saturate subst)
    apply-subst-unions
    cleanup-subst

    subsume-after-helpers

    (saturate boundary-analysis)
)
)


